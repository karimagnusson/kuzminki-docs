<!DOCTYPE html>
<html lang="en"> 
<head>
  <title>Kuzminki</title>
  
  <!-- Meta -->
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <meta name="description" content="Kuzminki-zio access library for PostgreSQL and ZIO">
  <link rel="shortcut icon" href="favicon.ico"> 
  
  <!-- Google Font -->
  <link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700&display=swap" rel="stylesheet">
  
  <!-- FontAwesome JS-->
  <script defer src="assets/fontawesome/js/all.min.js"></script>
  
  <!-- Plugins CSS -->
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.2/styles/monokai-sublime.min.css">
  <link rel="stylesheet" href="assets/plugins/simplelightbox/simple-lightbox.min.css">
  <!--<link rel="stylesheet" href="assets/css/atom-one-light.min.css">-->
  <!--<link rel="stylesheet" href="assets/css/monokai-sublime.min.css">-->

  <!-- Theme CSS -->  
  <link id="theme-style" rel="stylesheet" href="assets/css/theme.css">
  <style>
  	pre {margin: 0 !important; padding: 0 !important;}
  	.docs-code-block {
  		margin-top: 0 !important;
  		margin-bottom: 0 !important;
  		padding-top: 0 !important;
  		padding-bottom: 0 !important;
  	}
  	.docs-article {padding: 1rem 2rem;}
  	.docs-article .docs-section {padding-top: 1rem; padding-bottom: 0;}
  	a {color: #6a5acd;}
  	a:hover {color: #7b68ee;}
  	.nav-item.active .nav-link {color: #663399;}
		.theme-icon-holder {background: #e6e6fa; color: #663399;}
		.docs-nav .nav-item .nav-link:before {background-color: #e6e6fa;}
		.docs-nav .nav-item.active .nav-link {color: #663399;}
		.docs-nav .nav-item.active .nav-link .theme-icon-holder {background: #663399; color: #dcd0ff;}
		.docs-nav .nav-item.active .nav-link:before {background-color: #663399;}
		.social-list li {background: #ffffff;}
		.social-list li a {color: #6a5acd; background: #ffffff;}
		code {background: #e6e6fa;}
		/*.site-logo .logo-text {color: #f92672;}/*
	</style>

  <script type="text/javascript">
    var req = new XMLHttpRequest();
    req.open('GET', '/hit');
    req.send();
  </script>

	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-JW532LFCYV"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-JW532LFCYV');
	</script>
</head> 

<body class="docs-page">    
  <header class="header fixed-top">	    
    <div class="branding docs-branding">
      <div class="container-fluid position-relative py-2">
        <div class="docs-logo-wrapper">
					<button id="docs-sidebar-toggler" class="docs-sidebar-toggler docs-sidebar-visible me-2 d-xl-none" type="button">
            <span></span>
            <span></span>
            <span></span>
          </button>
          <div class="site-logo">
          	<a class="navbar-brand" href="index.html">
          		<!--<img class="logo-icon me-2" src="assets/images/coderdocs-logo.svg" alt="logo">-->
          		<span class="logo-text">Kuzminki</span>
          	</a>
          </div>    
        </div><!--//docs-logo-wrapper-->
        <div class="docs-top-utilities d-flex justify-content-end align-items-center">
					<ul class="social-list list-inline mx-md-3 mx-lg-5 mb-0 d-none d-lg-flex">
						<li class="list-inline-item">
							<a href="https://github.com/karimagnusson/kuzminki-zio" target="_blank"><i class="fab fa-github fa-fw"></i></a>
						</li>
          </ul><!--//social-list-->
        </div><!--//docs-top-utilities-->
      </div><!--//container-->
    </div><!--//branding-->
  </header><!--//header-->
    
    
    <div class="docs-wrapper">
	    <div id="docs-sidebar" class="docs-sidebar">
		    <nav id="docs-nav" class="docs-nav navbar">
			    <ul class="section-items list-unstyled nav flex-column pb-3">
				    
            <li class="nav-item section-title"><a class="nav-link scrollto" href="#section-1"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Introduction</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-1-1">Installation</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-1-2">Example</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-1-3">Results</a></li>
				    
            <li class="nav-item section-title"><a class="nav-link scrollto" href="#section-2"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Connecting</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-2-1">Config</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-2-2">Layer</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-2-3">Custom connection</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-2-4">Split connection</a></li>
				    
            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-3"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Model</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-3-1">Creating a model</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-3-2">Custom methods</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-3-3">Create model instance</a></li>
				    
            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-4"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Select</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-4-1">Select query</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-4-2">Row as case class</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-4-3">Row as Seq</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-4-4">Row as JSON</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-4-5">Where</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-4-6">AND / OR</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-4-7">Optional conditions</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-4-8">Null values</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-4-9">Distinct</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-4-10">Nested query</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-4-11">Cache</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-4-12">Cached with WHERE</a></li>
				    
            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-5"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Joins</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-5-1">Join</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-5-2">Extended Join</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-5-3">Join types</a></li>
				    
            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-6"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Insert</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-6-1">Basic insert</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-6-2">Insert case class</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-6-3">Insert returning</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-6-4">Insert on conflict do nothing</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-6-5">Upsert</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-6-6">Insert where not exists</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-6-7">Insert from select</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-6-8">Insert many</a></li>
			    	
            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-7"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Update</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-7-1">Update statement</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-7-2">Update returning</a></li>
				    
            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-8"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Delete</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-8-1">Delete statement</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-8-2">Delete returning</a></li>
				    
            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-9"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Aggregation</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-9-1">Count</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-9-2">Avg Max Min</a></li>

            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-10"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Streaming</a></li>
            
            <li class="nav-item"><a class="nav-link scrollto" href="#item-10-1">Stream from the database</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-10-2">Streaming into the database</a></li>

            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-11"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Transaction</a></li>
            
            <li class="nav-item"><a class="nav-link scrollto" href="#item-11-1">Execute multiple operations</a></li>

            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-12"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Fields</a></li>
            
            <li class="nav-item"><a class="nav-link scrollto" href="#item-12-1">Jsonb field</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-12-2">Array field</a></li>

            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-13"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Functions</a></li>
            
            <li class="nav-item"><a class="nav-link scrollto" href="#item-13-1">Postgres functions</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-13-2">Functions as methods</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-13-3">Create functions</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-13-4">Available functions</a></li>

            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-14"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Raw statements</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-14-1">Select</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-14-2">Operation</a></li>
				    
            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-15"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Data types and operators</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-15-1">Data types</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-15-2">Operators</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-15-3">Update operators</a></li>
			    
          </ul>
		    </nav>
	    </div>

      <!-- Introduction -->

	    <div class="docs-content">
		    <div class="container">
			    <article class="docs-article" id="section-1">
				    <header class="docs-header">
					    <h1 class="docs-heading">Introduction <span class="docs-time">Last updated: 2022-08-06</span></h1>
					    <section class="docs-intro">
						  	<p>Kuzminki is query builder and access library for PostgreSQL written in Scala.</p>

								<p>Kuzminki is written for those who like SQL. Queries are written with the same logic you write SQL statements. As a result the code is easy to read and memorise while the resulting SQL statement is predictable.</p>

                <p>Kuzminki is available for ZIO, ZIO 2</p>

                <p>On Github for ZIO 1<a href="https://github.com/karimagnusson/kuzminki-zio" target="_blank">
                  https://github.com/karimagnusson/kuzminki-zio
                </a></p>

                <p>On Github for ZIO 2<a href="https://github.com/karimagnusson/kuzminki-zio-2" target="_blank">
                  https://github.com/karimagnusson/kuzminki-zio-2
                </a></p>
						</section>
					</header>

					<section class="docs-section" id="item-1-1">
						<h2 class="section-heading">Installation</h2>
            <!--<p>Compiled for Scala 2.12. You can find jars compiled for 2.11 and 2.13 <a href="#item-12-1">below</a></p>-->
            <p>Attention! There are some changes to the API in this version. They affect INSERT, UPDATE and DELETE.</p>
						<h5>For ZIO 1</h5>
            <div class="docs-code-block">
							<pre class="rounded"><code class="hljs">libraryDependencies += "io.github.karimagnusson" % "kuzminki-zio" % "0.9.4-RC3"</code></pre>
						</div>
            <h5 style="margin-top: 10px;">For ZIO 2</h5>
            <div class="docs-code-block">
              <pre class="rounded"><code class="hljs">libraryDependencies += "io.github.karimagnusson" % "kuzminki-zio-2" % "0.9.4-RC3"</code></pre>
            </div>
            <p> </p>
            <p>If you need an older version of this documentation:</p>
            <div>
              <a href="0.9.4-RC1.html">0.9.4-RC1</a>
            </div>
            <div>
              <a href="0.9.2.html">0.9.2</a>
            </div>
					</section>

				  <section class="docs-section" id="item-1-2">
						<h2 class="section-heading">Example</h2>
            <p>This example is for ZIO. For ZIO 2 and Akka refer to the respective github pages.
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">import zio._
import zio.console._
import zio.blocking._
import kuzminki.api._

object ExampleApp extends zio.App {

  class Client extends Model("client") {
    val id = column[Int]("id")
    val username = column[String]("username")
    val age = column[Int]("age")
    def all = (id, username, age)
  }

  val client = Model.get[Client]

  val job = for {
    _ <- sql
      .insert(client)
      .cols2(t => (t.username, t.age))
      .values(("Joe", 35))
      .run
    
    _ <- sql
      .update(client)
      .set(_.age ==> 24)
      .where(_.id === 4)
      .run
    
    _ <- sql.delete(client).where(_.id === 7).run
    
    clients <- sql
      .select(client)
      .cols3(_.all)
      .where(_.age > 25)
      .limit(5)
      .run
    
    _ <- ZIO.foreach(clients) {
      case (id, username, age) =>
        putStrLn(s"$id $username $age")
    }
  } yield ()

  val dbConfig = DbConfig.forDb("company")
  val dbLayer = Kuzminki.layer(dbConfig)

  override def run(args: List[String]): ZIO[ZEnv, Nothing, ExitCode] = {
    job.provideCustomLayer(dbLayer).exitCode
  }
}</code>
							</pre>
						</div>
					</section>

				  <section class="docs-section" id="item-1-3">
          	<h2 class="section-heading">Results</h2>

            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">// query
val stm = sql.select(client).cols3(_.all).where(_.age > 25).limit(5)
stm.run: List[T]
stm.runHead: T
stm.runHeadOpt: Option[T]

// modify row
implicit val toMyType: SomeRow => MyType = row => //...
stm.runAs[MyType]: List[MyType]
stm.runHeadAs[MyType]: MyType
stm.runHeadOptAs[MyType]: Option[MyType]

// operation
val stm = sql.update(client).set(_.age ==> 24).where(_.id === 4)
stm.run: Unit
stm.runNum: Int</code>
              </pre>
            </div>
          </section>
        </article>

        <!-- Connecting to the database -->

				<article class="docs-article" id="section-2">
				  <header class="docs-header">
				    <h1 class="docs-heading">Connecting to the database</h1>
					</header>
					
					<section class="docs-section" id="item-2-1">
						<h2 class="section-heading">Config</h2>
            <p>For Akka replace <code>forDb("{DB-NAME}")</code> with <code>withDispatcher("{NAME}")</code> default = "kuzminki-dispatcher"</p>
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">val dbConfig = DbConfig
  .forDb("{DB-NAME}")
  .withPoolSize(10) // default = 10
  .withHost("{HOST}") // default = localhost
  .withPort("{PORT}") // default = 5432
  .withUser("{USER}}")
  .withPassword("{PASSWORD}")
  .withOptions(Map(...))</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-2-2">
          	<h2 class="section-heading">Layer</h2>
          	<p>Create a layer to make the driver instance accessable under <code>Has[Kuzminki]</code></p>
            <p>For ZIO 1</p>
            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">object MyApp extends zio.App {
  val job = // ...
  val dbLayer = Kuzminki.layer(DbConfig.forDb("company"))

  override def run(args: List[String]): ZIO[ZEnv, Nothing, ExitCode] = {
    job.provideCustomLayer(dbLayer).exitCode
  }
}</code>
            	</pre>
            </div>
            <p>For ZIO 2</p>
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">object MyApp extends ZIOAppDefault {
  // ...
  def run = job.provide(dbLayer)
}</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-2-3">
          	<h2 class="section-heading">Custom connection</h2>
            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">for { 
  db <- Kuzminki.create(dbConfig)
  users <- db.query {
    sql.select(user).cols1(_.username.all.orderBy(_.id.asc)
  }
} yield users</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-2-4">
          	<h2 class="section-heading">Split connection</h2>
          	<p>If you wish to have two connection pools, one for SELECT and another for INSERT, UPDATE, DELETE, you can use <code>layerSplit</code>. To create an instance rather than a Layer, use <code>createSplit</code>.</p>
            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">// for .query .queryHead .queryHeadOpt
val getConfig = DbConfig.forDb("company").withPoolSize(5)

// for .exec .execNum
val setConfig = DbConfig.forDb("company").withPoolSize(5)

val dbLayer = Kuzminki.layerSplit(getConfig, setConfig)</code>
            	</pre>
            </div>

					</section><!--//section-->
				</article>

        <!-- Model -->

				<article class="docs-article" id="section-3">
				  <header class="docs-header">
				    <h1 class="docs-heading">Model</h1>
					</header>
					
					<section class="docs-section" id="item-3-1">
						<h2 class="section-heading">Creating a model</h2>
						<p>Column types are listed under <a href="#item-11-1">Data types</a></p>
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">import kuzminki.api._
import java.sql.Timestamp

class User extends Model("user_profile") {
  val id = column[Int]("id")
  val username = column[String]("username")
  val email = column[String]("email")
  val name = column[String]("name")
  val age = column[Int]("age")
  val gender = column[String]("gender")
  val country = column[String]("country")
  val city = column[String]("city")
  val discount = column[Int]("discount")
  val isActive = column[Boolean]("is_active")
  val created = column[Timestamp]("created")
}

Model.register[User]</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-3-2">
          	<h2 class="section-heading">Custom methods</h2>
          	<p>You can create custom methods to access columns that you regularly use.</p>
            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">class Customer extends Model("customer") {
  val id = column[Int]("id")
  val userId = column[Int]("user_id")
  val spending = column[Int]("spending")
  def all = (id, userId, spending)
}</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-3-3">
          	<h2 class="section-heading">Create a model instance</h2>
          	<p><code>Model.register[User]</code> creates an instance of the model for later use and makes sure there is only one instance of the model. <code>Model.register[User]</code> gets an existing instance of the model. If it does not exist, it is created.</p>
            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">Model.register[User]
// ...
val user = Model.get[User]</code>
            	</pre>
            </div>
          </section>
          </article>

          <!-- Select -->

			    <article class="docs-article" id="section-4">
				    <header class="docs-header">
					    <h1 class="docs-heading">Select</h1>
					    <section class="docs-intro">
						    
						</section><!--//docs-intro-->
				    </header>
				    <section class="docs-section" id="item-4-1">
							<h2 class="section-heading">Select query</h2>
							<p>You select the columns as tuple of model columns. The query will return tuple of the column types. In this case <code>Seq[Tuple2[Int, String]]</code>. If you need more than 22 columns you can use <code>colsSeq</code> or <code>colsType</code>. To order by <code>ASC</code> rather than <code>DESC</code> use <code>orderBy(_.age.asc)</code>.
						 	<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">import kuzminki.api._

val user = Model.get[User]

sql
  .select(user)
  .cols2(t => (
    t.id,
    t.username
  ))
  .where(t => Seq(
    t.gender === "f",
    t.age > 25
  ))
  .orderBy(_.age.desc)
  .limit(10)
  .run</code>
            	</pre>
            </div>

            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-pgsql hljs">SELECT
  "id",
  "username"
FROM "user_profile"
WHERE "gender" = 'f'
AND "age" > 25
ORDER BY "age" DESC
LIMIT 10</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-2">
          <h2 class="section-heading">Row as case class</h2>
          <div class="docs-code-block">
            <pre class="rounded">
              <code class="language-scala hljs">case class ProductItem(id: Int, name: String, price: Float)

class Product extends Model("product") {
  val id = column[Int]("id")
  val name = column[String]("name")
  val price = column[Float]("price")
  val item = read[ProductItem](id, name, price)
}

val product = Model.get[Product]

sql
  .select(product)
  .colsType(_.item)
  .where(_.price < 100.0)
  .run
  // returns List[ProductItem]</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-3">
          <h2 class="section-heading">Row as Seq</h2>
          <div class="docs-code-block">
            <pre class="rounded">
              <code class="language-scala hljs">sql
  .select(user)
  .colsSeq(t => List(
    t.id,
    t.username,
    t.email
  ))
  .where(_.age < 25)
  .run
  // returns List[Vector[Any]]</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-4">
            <h2 class="section-heading">Row as JSON</h2>
            <p>You can get the result as JSON, using your favorite JSON library. It comes in handy if you are, for example, writing a REST web service.</p>
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">// See PlayJsonLoader below
implicit val loadJson: Seq[Tuple2[String, Any]] => JsValue = data => PlayJsonLoader.load(data)

sql
  .select(user)
  .colsNamed(t => List(
    t.id,        // Column name is used as a key.
    t.username,  // If you want a different key:
    t.email      // ("user_id"  -> t.id)
  ))
  .where(_.age < 25)
  .runAs[JsValue]
  // returns List[JsValue]</code>
              </pre>
            </div>

            <p>Write something along these lines to use the JSON library of your choosing.</p>

            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">import java.util.UUID
import java.sql.Time
import java.sql.Date
import java.sql.Timestamp
import play.api.libs.json._
import kuzminki.api.Jsonb

object PlayJsonLoader {

  val toJsValue: Any => JsValue = {
    case v: String      => JsString(v)
    case v: Boolean     => JsBoolean(v)
    case v: Short       => JsNumber(v)
    case v: Int         => JsNumber(v)
    case v: Long        => JsNumber(v)
    case v: Float       => JsNumber(v)
    case v: Double      => JsNumber(v)
    case v: BigDecimal  => JsNumber(v)
    case v: Time        => Json.toJson(v)
    case v: Date        => Json.toJson(v)
    case v: Timestamp   => Json.toJson(v)
    case v: UUID        => JsString(v.toString)
    case v: Jsonb       => Json.parse(v.value)
    case v: Option[_]   => v.map(toJsValue).getOrElse(JsNull)
    case v: Seq[_]      => JsArray(v.map(toJsValue))
    case v: JsValue     => v
    case _              => throw new Exception("Cannot convert to JsValue")
  }

  def load(data: Seq[Tuple2[String, Any]]): JsValue = {
    JsObject(data.map(p => (p._1, toJsValue(p._2))))
  }
}</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-5">
          	<h2 class="section-heading">Where</h2>
          	<p>Refer to <a href="#item-11-2">Operators</a> for a list of operators.</p>
            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">.where(_.id > 100)

.where(t => Seq(
  t.gender === "f",
  t.age > 25
))</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-6">
          	<h2 class="section-heading">AND / OR</h2>
          	<p>
            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">import kuzminki.fn._

.where(t => Seq(
  t.age > 25,
  Or(
    t.country === "RU",
    t.country === "FR"
  )
))
// WHERE "age" > 25 AND ("country" == 'RU' OR "country" == 'FR')

.where(t => Or(
  And(
    t.country === "RU",
    t.city === "Moscow"
  ),
  And(
    t.country === "FR",
    t.city === "Paris"
  )
))
// WHERE ("country" == 'RU' AND "city" == 'Moscow') OR ("country" == 'FR' AND "city" == 'Paris')</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-7">
          	<h2 class="section-heading">Optional conditions</h2>
          	<p>Optional conditions for example from http GET request.</p>
            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">.whereOpt(_.id > Some(100))

.whereOpt(t => Seq(
  t.gender === None,
  t.age > Some(25)
))
// WHERE "age" > 25

.whereOpt(t => Seq(
  t.age > Some(25),
  Or.opt(
    t.country === Some("RU"),
    t.country === Some("FR")
  )
))
// WHERE "age" > 25 AND ("country" == 'RU' OR "country" == 'FR')</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-8">
          	<h2 class="section-heading">Null values</h2>
          	<p>If you have null values in a column you can use one of the folloing ways to turn the result into <code>Option[T]</code></p>
            <div class="docs-code-block">
            	<p>Convert the column in the model from <code>T</code> to <code>Option[T]</code></p>
            	<pre class="rounded">
								<code class="language-scala hljs">val city = column[String]("city").asOpt</code>
							</pre>
							<p>Convert the column in the query from <code>T</code> to <code>Option[T]</code></p>
							<pre class="rounded">
								<code class="language-scala hljs">cols1(_.city.asOpt)</code>
							</pre>
							<p>Use Posgres's coalesce function to return a default value in case of null</p>
							<pre class="rounded">
								<code class="language-scala hljs">import kuzminki.fn._
cols1(t => t.city.default("No city"))</code>
							</pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-9">
            <h2 class="section-heading">Distinct</h2>
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">sql
  .select(user)
  .cols2(t => (
    t.username,
    t.age
  ))
  .distinct
  .all
  .orderBy(_.age.asc)
  .run</code>
              </pre>

              <pre class="rounded">
                <code class="language-pgsql hljs">SELECT DISTINCT "username", "age"
FROM "user_profile"
ORDER BY "age" ASC
)</code>
              </pre>

              <pre class="rounded">
                <code class="language-scala hljs">sql
  .select(user)
  .cols2(t => (
    t.username,
    t.age
  ))
  .distinctOn(_.age)
  .all
  .orderBy(_.age.asc)
  .run</code>
              </pre>

              <pre class="rounded">
                <code class="language-pgsql hljs">SELECT DISTINCT ON ("age") "username", "age"
FROM "user_profile"
ORDER BY "age" ASC
)</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-10">
          	<h2 class="section-heading">Nested query</h2>
            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">class Newsletter extends Model("newsletter") {
  val email = column[String]("email")
  val isSubscribed = column[Boolean]("is_subscribed")
}

val newsletter = Model.get[Newsletter]

sql
  .select(user)
  .cols1(_.username)
  .where(_.email.in(
    sql
      .select(newsletter)
      .cols1(_.email)
      .where(_.isSubscribed === true)
  ))
  .run</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">SELECT "username"
FROM "user_profile"
WHERE "email" = ANY(
  SELECT "email"
  FROM "newsletter"
  WHERE "is_subscribed" = true
)</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-11">
          	<h2 class="section-heading">Cache</h2>
          	<p>For increased performance and reusability queries can be cached. The SQL string will be created only once and you get the same performance as you get with raw queries.</p>
            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">val stm = sql
  .select(user)
  .cols1(_.username)
  .all
  .orderBy(_.age.asc)
  .cacheWhere2(t => (
    t.country.oprEq,
    t.age.oprGt
  ))

stm.run(("CN", 25))</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">SELECT "username"
FROM "user_profile"
WHERE "country" = 'CN'
AND "age" > 25
ORDER BY "age" ASC</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-12">
          	<h2 class="section-heading">Cached with WHERE</h2>
            <p>You can use normal WHERE conditions with cached queries.</p>
            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">val stm = sql
  .select(user)
  .cols1(_.username)
  .where(_.age > 25)
  .orderBy(_.age.asc)
  .cacheWhere1(_.country.oprEq)

stm.run("CN")</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">SELECT "username"
FROM "user_profile"
WHERE "age" > 25
AND "country" = 'CN'
ORDER BY "age" ASC</code>
            	</pre>
            </div>
          </section>

        </article>

        <!-- Join -->

        <article class="docs-article" id="section-5">
			    <header class="docs-header">
				    <h1 class="docs-heading">Join</h1>
			    </header>
			    <section class="docs-section" id="item-5-1">
						<h2 class="section-heading">Select join</h2>
						<p>To do Joins you just put two model instances as arguments and the models will be accessable under <code>a</code> and <code>b</code></p>
					 	<div class="docs-code-block">
						<pre class="rounded">
							<code class="language-scala hljs">sql
  .select(user, customer)
  .cols3(t => (
    t.a.id,
    t.a.username,
    t.b.spending
  ))
  .joinOn(_.id, _.userId)
  .where(t => Seq(
    t.a.age > 25,
    t.b.spending > 1000
  ))
  .orderBy(_.b.spending.desc)
  .limit(10)
  .run
  // returns List[Tuple3[Int, String, Int]]</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">SELECT
  "a"."id",
  "a"."username",
  "b"."spending"
FROM "user_profile" "a"
INNER JOIN "customer" "b"
ON "a"."id" = "b"."user_id"
WHERE "a"."age" > 25
AND "b"."spending" > 1000
ORDER BY "b"."spending" DESC
LIMIT 10</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-5-2">
            <h2 class="section-heading">Join result types</h2>
            <p>You can have a join query return a case class.</p>
            <div class="docs-code-block">
            <pre class="rounded">
              <code class="language-scala hljs">case class UserSpending(userId: Int, username: String, spending: Int)

class UserCustomer extends JoinRead[User, Customer] {
  val userSpending = read[UserSpending](a.id, a.username, b.spending)
}

val userCustomer = new UserCustomer
implicit val userCustomerConv = userCustomer.convert

sql
  .select(userCustomer)
  .colsType(_.userSpending)
  .joinOn(_.id, _.userId)
  .where(_.a.age > 25)
  .orderBy(_.b.spending.desc)
  .limit(10)
  .run
  // returns List[UserCustomer]</code>
              </pre>
              <p>You can also define results as tuples or a Vector</p>
              <pre class="rounded">
                <code class="language-pgsql hljs">class UserCustomer extends JoinRead[User, Customer] {
  val userSpending = read[UserSpending](a.id, a.username, b.spending)
  // colsType(_.userSpending)

  val userSpendingTuple = (a.id, a.username, b.spending)
  // cols3(_.userSpendingTuple)

  val userSpendingVector = Vector(a.id, a.username, b.spending)
  // colsVector(_.userSpendingVector)
}</code>
              </pre>
              <pre class="rounded">
                <code class="language-pgsql hljs">SELECT
  "a"."id",
  "a"."username",
  "b"."spending"
FROM "user_profile" "a"
INNER JOIN "customer" "b"
ON "a"."id" = "b"."user_id"
WHERE "a"."age" > 25
ORDER BY "b"."spending" DESC
LIMIT 10</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-5-3">
					<h2 class="section-heading">Join types</h2>
					<p>The following joins are available. Refer to the section <a href="#item-4-5">Null values</a> to avoid problems that may come up with joins.
					 <div class="docs-code-block">
						<pre class="rounded">
							<code class="language-scala hljs">.joinOn(_.id, _.userId) // INNER JOIN

.innerJoinOn(_.id, _.userId) // INNER JOIN

.leftJoinOn(_.id, _.userId) // LEFT JOIN

.leftOuterJoinOn(_.id, _.userId) // LEFT OUTER JOIN
 
.rightJoinOn(_.id, _.userId) // RIGHT JOIN

.rightOuterJoinOn(_.id, _.userId) // RIGHT OUTER JOIN

.fullOuterJoinOn(_.id, _.userId) // FULL OUTER JOIN

.crossJoin // CROSS JOIN</code>
            	</pre>
            </div>
          </section>

      	</article>

        <!-- Insert -->

				<article class="docs-article" id="section-6">
			    <header class="docs-header">
				    <h1 class="docs-heading">Insert</h1>
			    </header>
			    <section class="docs-section" id="item-6-1">
					<h2 class="section-heading">Basic insert</h2>
					<div class="docs-code-block">
						<pre class="rounded">
							<code class="language-scala hljs">sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .values(("bob", "bob@mail.com"))
  .run</code>
            </pre>
          </div>

<span>If you need to insert more than the tuple limit of 22.</span>

          <div class="docs-code-block">
            <pre class="rounded">
              <code class="language-scala hljs">sql
  .insert(user)
  .data(t => Seq(
    t.username ==> "bob",
    t.email ==> "bob@mail.com"
  ))
  .run</code>
            </pre>
          </div>

<span>For increased performance and reusability queries can be cached.</span>

          <div class="docs-code-block">
            <pre class="rounded">
              <code class="language-scala hljs">val stm = sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .cache

stm.run(("bob", "bob@mail.com"))</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">INSERT INTO "user_profile" ("username", "email") VALUES ('bob', 'bob@mail.com')</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-6-2">
          <h2 class="section-heading">Insert case class</h2>
          <div class="docs-code-block">
            <pre class="rounded">
              <code class="language-scala hljs">case class AddProduct(name: String, price: Float)

class Product extends Model("product") {
  val id = column[Int]("id")
  val name = column[String]("name")
  val price = column[Float]("price")
  val add = write[AddProduct](name, price)
}

val product = Model.get[Product]

sql
  .insert(product)
  .colsType(_.add)
  .values(AddProduct("Banana", 12.5))
  .run

// cache
val stm = sql
  .insert(product)
  .colsType(_.add)
  .cache

stm.run(AddProduct("Banana", 12.5))
</code>
              </pre>
              <pre class="rounded">
                <code class="language-pgsql hljs">INSERT INTO "product" ("name", "price") VALUES ('Banana', 12.5)</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-6-3">
					<h2 class="section-heading">Insert returning</h2>
					<div class="docs-code-block">
						<pre class="rounded">
							<code class="language-scala hljs">sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .values(("bob", "bob@mail.com"))
  .returning3(t => (
    t.id,
    t.username,
    t.email
  ))
  .runHead

// cache
val stm = sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .returning3(t => (
    t.id,
    t.username,
    t.email
  ))
  .cache

stm.run(("bob", "bob@mail.com"))</code>
            	</pre>
							
              <pre class="rounded">
								<code class="language-pgsql hljs">INSERT INTO "user_profile"
("username", "email")
VALUES ('bob', 'bob@mail.com')
RETURNING
  "id",
  "username",
  "email"</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-6-4">
					  <h2 class="section-heading">Insert on conflict do nothing</h2>
					  <p>You can take advantage of <code>ON CONFLICT DO NOTHING</code> to avoid errors on columns with <code>UNIQUE</code> constraint.</p>
					  <div class="docs-code-block">
						  <pre class="rounded">
							  <code class="language-scala hljs">sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .values(("bob", "bob@mail.com"))
  .onConflictDoNothing
  .run

// cache
val stm = sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .onConflictDoNothing
  .cache

stm.run(("bob", "bob@mail.com"))</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">INSERT INTO "user_profile"
("username", "email")
VALUES ('bob', 'bob@mail.com')
ON CONFLICT DO NOTHING</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-6-5">
					<h2 class="section-heading">Upsert</h2>
					<p>The updated column has to be one of the columns you intend to insert.</p>
					<div class="docs-code-block">
						<pre class="rounded">
							<code class="language-scala hljs">sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .values(("bob", "bob@hotmail.com"))
  .onConflictOnColumn(_.username)
  .doUpdate(_.email) // .doNothing is also an option
  .run

// cache
val stm = sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .onConflictOnColumn(_.username)
  .doUpdate(_.email)
  .cache

stm.run(("bob", "bob@hotmail.com"))</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">INSERT INTO "user_profile"
("username", "email")
VALUES ('bob', 'bob@mail.com')
ON CONFLICT ("username")
DO UPDATE SET "email" = 'bob@mail.com'</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-6-6">
					<h2 class="section-heading">Insert where not exists</h2>
					<p>If you need to avoid duplication on a column that does not have a unique constraint you can use <code>whereNotExists</code>. Also, if you are makeing multible insert statements concurrently, from a stream for example, you will run into problems using <code>onConflictDoNothing</code>.<p>
					<div class="docs-code-block">
						<pre class="rounded">
							<code class="language-scala hljs">sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .values(("bob", "bob@mail.com"))
  .whereNotExists(_.username)
  .run

// cache
val stm = sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .whereNotExists(_.username)
  .cache

stm.run(("bob", "bob@mail.com"))</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">INSERT INTO "user_profile"
("username", "email")
SELECT 'bob', 'bob@mail.com'
WHERE NOT EXISTS (
  SELECT 1
  FROM "user_profile"
  WHERE "username" = 'bob'
)</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-6-7">
					<h2 class="section-heading">Insert from select</h2>
					<div class="docs-code-block">
						<pre class="rounded">
							<code class="language-scala hljs">sql
  .insert(newsletter)
  .cols1(_.email)
  .fromSelect(
    sql
      .select(user)
      .cols1(_.email)
      .where(_.isActive === true)
  )
  .run

// cache not available</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">INSERT INTO "newsletter" ("email")
SELECT "email"
FROM "user_profile"
WHERE "is_active" = true</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-6-8">
          <h2 class="section-heading">Insert many</h2>
          <div class="docs-code-block">
            <pre class="rounded">
              <code class="language-scala hljs">val stm = sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .cache

stm.runList(Seq(
  ("bob", "bob@mail.com"),
  ("jane", "jane@mail.com"),
  ("jack", "jack@mail.com")
))</code>
              </pre>
            </div>
          </section>
        </article>

        <!-- Update -->

        <article class="docs-article" id="section-7">
				  <header class="docs-header">
				    <h1 class="docs-heading">Update</h1>
					</header>
					
					<section class="docs-section" id="item-7-1">
						<h2 class="section-heading">Update statement</h2>
						<p>See <a href="#item-11-3">Update operators</a></p>
						<p></p>
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">sql
  .update(user)
  .set(_.country ==> "JP")
  .where(_.id === 103)
  .run

// cache
val stm = sql
  .update(user)
  .pickSet1(_.country.modSet)
  .pickWhere1(_.id.oprEq)
  .cache

stm.run("JP", 103)</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">UPDATE "user" SET "country" = 'JP' WHERE id = 103</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-7-2">
						<h2 class="section-heading">Update returning</h2>
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">sql
  .update(user)
  .set(t => Seq(
    t.country ==> "IS",
    t.city ==> "Reykjavik"
  ))
  .where(_.id === 31)
  .returning3(t => (
    t.id,
    t.country,
    t.city
  ))
  .runHeadOpt

// cache
val stm = sql
  .update(user)
  .pickSet2(t => (
    t.country.modSet,
    t.city.modSet
  ))
  .pickWhere1(_.id.oprEq)
  .returning3(t => (
    t.id,
    t.country,
    t.city
  ))
  .cache

stm.runHeadOpt(("IS", "Reykjavik"), 31)</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">UPDATE "user_profile"
SET country = 'IS',
       city = 'Reykjavik'
WHERE "id" = 31
RETURNING
  "id",
  "country",
  "city"</code>
            	</pre>
            </div>
          </section>
        </article>

        <!-- Delete -->

        <article class="docs-article" id="section-8">
				  <header class="docs-header">
				    <h1 class="docs-heading">Delete</h1>
					</header>
					
					<section class="docs-section" id="item-8-1">
						<h2 class="section-heading">Delete statement</h2>
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">sql
  .delete(user)
  .where(_.id === 103)
  .run

// cache
val stm = sql
  .delete(user)
  .pickWhere1(_.id.oprEq)
  .cache

stm.run(103)</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">DELETE FROM "user_profile" WHERE "id" = 103</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-8-2">
						<h2 class="section-heading">Delete returning</h2>
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">val stm = sql
  .delete(user)
  .where(_.id === 103)
  .returning1(_.email)
  .runHeadOpt

// cache
val stm = sql
  .delete(user)
  .pickWhere1(_.id.oprEq)
  .returning1(_.email)

stm.runHeadOpt(103)</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">DELETE FROM "user_profile"
WHERE "id" = 103
RETURNING "email"</code>
            	</pre>
            </div>
          </section>
        </article>

        <!-- Aggregation -->

        <article class="docs-article" id="section-9">
				  <header class="docs-header">
				    <h1 class="docs-heading">Aggregation</h1>
					</header>
					
					<section class="docs-section" id="item-9-1">
						<h2 class="section-heading">Count</h2>
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">sql
  .count(user)
  .where(_.country === "IT")
  .runHead</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">SELECT count(*) FROM "user_profile" WHERE "country" = 'IT'</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-9-2">
						<h2 class="section-heading">Avg Max Min</h2>
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">import kuzminki.api._
import kuzminki.fn._

sql
  .select(user)
  .cols3(t => (
    Agg.avg(t.age),
    Agg.max(t.age),
    Agg.min(t.age)
  ))
  .where(_.country === "US")
  .runHead</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">SELECT
  avg("age"),
  max("age"),
  min("age")
FROM "user_profile"
WHERE "country" = 'US'</code>
            	</pre>
            </div>
          </section>
        </article>

        <!-- Streaming -->

        <article class="docs-article" id="section-10">
          <header class="docs-header">
            <h1 class="docs-heading">Streaming</h1>
          </header>
          
          <section class="docs-section" id="item-10-1">
            <h2 class="section-heading">Stream from the database</h2>
            <p>Streaming is done in batches. By default a batch of 100. For a larger batch use .streamBatch(1000)</p>
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">sql
  .select(client)
  .cols3(_.all)
  .all
  .orderBy(_.id.asc)
  .stream // .streamBatch(1000)
  .map(makeLine)
  .run(fileSink(Paths.get("clints.txt")))</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-10-2">
            <h2 class="section-heading">Stream into the database</h2>
            <p>The same logic can be used for UPDATE and DELETE.</p>
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">val insertStm = sql
  .insert(client)
  .cols2(t => (t.username, t.age))
  .cache

// insert one at a time.
readFileIntoStream("clints.txt")
  .map(makeTupleFromLine)
  .run(insertStm.asSink)

// insert in chunks of 100 using transaction.
readFileIntoStream("clints.txt")
  .map(makeTupleFromLine)
  .transduce(insertStm.collect(100))
  .run(insertStm.asChunkSink)</code>
              </pre>
            </div>
          </section>
        </article>

        <!-- Transaction -->

        <article class="docs-article" id="section-11">
          <header class="docs-header">
            <h1 class="docs-heading">Transaction</h1>
          </header>

          <section class="docs-section" id="item-11-2">
            <h2 class="section-heading">Execute multiple operations</h2>
            <p>Do INSERT, UPDATE and DELETE in one transaction.</p>
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">sql.transaction(
  sql.insert(user).cols2(t => (t.username, t.age)).values(("Joe", 25)),
  sql.update(user).set(_.age ==> 31).where(_.id === 45),
  sql.delete(user).where(_.id === 83)
).run</code>
              </pre>
            </div>

            <p>Execute a list of cached statements</p>

            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">val stm = sql
  .delete(user)
  .pickWhere1(_.id)
  .cache

val statements = (1 to 10).map(id => stm.render(id))

sql.transactionList(Seq(statements)).run</code>
              </pre>
            </div>
          </section>
        </article>

        <!-- Fields -->

        <article class="docs-article" id="section-12">
          <header class="docs-header">
            <h1 class="docs-heading">Fields</h1>
          </header>

          <section class="docs-section" id="item-12-1">
            <h2 class="section-heading">Jsonb field</h2>
            <p><a href="https://www.postgresql.org/docs/11/functions-json.html">https://www.postgresql.org/docs/11/functions-json.html</a></p>
            
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-json hljs">{
  "name": "Angela Barton",
  "is_active": true,
  "company": "Magnafone",
  "address": "178 Howard Place, Gulf, Washington, 702",
  "latitude": 19.793713,
  "longitude": 86.513373,
  "tags": ["enim", "aliquip", "qui"],
  "residents": {
    "name": "Rick",
    "age": 31
  }
}</code>
              </pre>
            </div>

            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">class Customer extends Model("customer") {
  val data = column[Jsonb]("data")
}

sql
  .insert(customer)
  .cols1(_.data)
  .values(Jsonb(jsonString))
  .run

// select

sql
  .select(customer)
  .cols1(_.data ->> "company")
  .where(_.id === 3)
  .runHead // "Magnafone"


sql
  .select(customer)
  .cols1(_.data #>> Seq("residents", "name"))
  .where(_.id === 3)
  .runHead // "Rick"


sql
  .select(customer)
  .cols1(_.data -> "tags" ->> 1)
  .where(_.id === 3)
  .runHead // "aliquip"


sql
  .select(customer)
  .cols1(_.data -> "residents")
  .where(_.id === 3)
  .runHead // Jsonb({"name" : "Rick", "age" : 31})

sql
  .select(customer)
  .cols1(_.data - "residents")
  .where(_.id === 3)
  .runHead

// update

sql
  .update(customer)
  .set(_.data += Json.obj("address" -> "Somewhere 12"))
  .where(_.id === 3)
  .run

  
sql
  .update(customer)
  .set(_.data -= "address")
  .where(_.id === 3)
  .run


sql
  .update(customer)
  .set(_.data #-= Seq("residents", "age"))
  .where(_.id === 3)
  .run</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-12-2">
            <h2 class="section-heading">Array field</h2>
            <p>Array fields can be created for all the available types. Array fields can be filtered using <code>has</code> <code>hasNot</code> <code>overlap</code> <code>overlapNot</code> and updated using <code>append</code> <code>prepend</code> <code>remove</code>.</p>
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">class Nums extends Model("demo") {
  val id = column[Int]("id")
  val numbers = column[Seq[Int]]("numbers")
}

val nums = Model.get[Nums]

for {
  id <- sql
    .insert(nums)
    .cols1(_.numbers)
    .values(List(1, 2, 3))
    .returning1(_.id)
    .run

  _ <- sql
    .update(nums)
    .set(_.numbers += 4) // append, prepend, remove
    .where(_.id === id)
    .run

  numbers <- sql
    .select(nums)
    .cols1(_.numbers)
    .where(_.numbers.has(2))  // has, hasNot, overlap, overlapNot
    .run
} yield numbers // List[Vector[Int]]</code>
              </pre>
            </div>
          </section>
        </article>

        <!-- Functions -->

        <article class="docs-article" id="section-13">
          <header class="docs-header">
            <h1 class="docs-heading">Functions</h1>
          </header>
          
          <section class="docs-section" id="item-13-1">
            <h2 class="section-heading">Postgres functions</h2>
            <p>Use postgres functions to modify results.</p>
            
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">import kuzminki.api._
import kuzminki.fn._

class Profile extends Model("profile") {
  val firstName = column[String]("first_name")
  val lastName = column[String]("last_name")
  val bigNum = column[BigDecimal]("big_num")
}

val profile = Model.get[Profile]

sql
  .select(profile)
  .cols3(t => (
    Fn.concatWs(" ", t.firstName, t.lastName),
    Fn.initcap(t.lastName),
    Cast.asString(t.bigNum)
  ))
  .all
  .run</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-13-2">
            <h2 class="section-heading">Functions as methods</h2>
            <p>Use functions as methods on columns.</p>
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">import kuzminki.column.TypeCol

implicit class RoundBigDecimal(col: TypeCol[BigDecimal]) {
  def round(size: Int) = Fn.round(col, size)
  def roundStr(size: Int) = Fn.roundStr(col, size)
}

sql
  .select(profile)
  .cols2(t => (
    bigNum.round(2),
    bigNum.roundStr(2)
  ))
  .all
  .run</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-13-3">
            <h2 class="section-heading">Create functions</h2>
            <p>Create your own function classes.</p>
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">import kuzminki.fn.types._

case class Length(col: TypeCol[String]) extends IntFn {
  val template = "length(%s)"
}

case class Left(col: TypeCol[String], size: Int) extends StringArgsFn {
  val template = "left(%s, ?)"
  def fnArgs = Vector(size)
}

sql
  .select(profile)
  .cols2(t => (
    Length(t.firstName),
    Left(t.lastName, 4)
  ))
  .all
  .run</code>
              </pre>
            </div>

          </section>

          <section class="docs-section" id="item-13-4">
            <h2 class="section-heading">Available functions</h2>
            <p><a href="https://www.postgresql.org/docs/current/functions-string.html">https://www.postgresql.org/docs/current/functions-string.html</a>
            <div class="table-responsive my-4">
              <table class="table table-bordered">
                <tbody>
                  <tr>
                      <th>Function</th>
                      <th>Column type</th>
                  </tr>
                  <tr>
                      <td>Fn.coalesce(col, default)</td>
                      <td>String</td>
                  </tr>
                   <tr>
                      <td>Fn.concat(col, ...)</td>
                      <td>String</td>
                  </tr>
                   <tr>
                      <td>Fn.concatWs(glue, col, ...)</td>
                      <td>String</td>
                  </tr>
                   <tr>
                      <td>Fn.substr(col, start)</td>
                      <td>String</td>
                  </tr>
                   <tr>
                      <td>Fn.substr(col, start, len)</td>
                      <td>String</td>
                  </tr>
                   <tr>
                      <td>Fn.trim(col)</td>
                      <td>String</td>
                  </tr>
                  <tr>
                      <td>Fn.upper(col)</td>
                      <td>String</td>
                  </tr>
                  <tr>
                      <td>Fn.lower(col)</td>
                      <td>String</td>
                  </tr>
                  <tr>
                      <td>Fn.initcap(col)</td>
                      <td>String</td>
                  </tr>
                  <tr>
                      <td>Fn.round(col)</td>
                      <td>BigDecimal</td>
                  </tr>
                  <tr>
                      <td>Fn.roundStr(col)</td>
                      <td>BigDecimal</td>
                  </tr>
                  <tr>
                      <td>Cast.asString(col)</td>
                      <td>Any</td>
                  </tr>
                  <tr>
                      <td>Cast.asShort(col)</td>
                      <td>Any</td>
                  </tr>
                  <tr>
                      <td>Cast.asInt(col)</td>
                      <td>Any</td>
                  </tr>
                  <tr>
                      <td>Cast.asLong(col)</td>
                      <td>Any</td>
                  </tr>
                  <tr>
                      <td>Cast.asFloat(col)</td>
                      <td>Any</td>
                  </tr>
                  <tr>
                      <td>Cast.asDouble(col)</td>
                      <td>Any</td>
                  </tr>
                  <tr>
                      <td>Cast.asBigDecimal(col)</td>
                      <td>Any</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
        </article>

        <!-- Raw SQL -->

        <article class="docs-article" id="section-14">
				  <header class="docs-header">
				    <h1 class="docs-heading">Raw SQL</h1>
					</header>
					
					<section class="docs-section" id="item-14-1">
						<h2 class="section-heading">Select</h2>
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">def rawStm(country: String, minAge: Int) =
  rsql"""SELECT * FROM "user_profile" WHERE country = $country AND age > $minAge"""

val job = for {
  users <- db.query(rawStm("TR", 25))
} yield users</code>
							</pre>
            </div>
          </section>

          <section class="docs-section" id="item-14-2">
						<h2 class="section-heading">Operations</h2>
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">val username = "bob"
val email = "bob@mail.com"

db.exec(rsql"""INSERT INTO "user_profile" ("username", "email") VALUES ($username, $email)""")</code>
            	</pre>
            </div>
          </section>
        </article>

        <!-- Data types and operators -->

        <article class="docs-article" id="section-15">
				  <header class="docs-header">
				    <h1 class="docs-heading">Data types and operators</h1>
					</header>
					
					<section class="docs-section" id="item-15-1">
						<h2 class="section-heading">Data types</h2>
						<div class="table-responsive my-4">
							<table class="table table-bordered">
								<tbody>
								  <tr>
									    <th class="theme-bg-light">Postgres</th>
									    <th>Scala</th>
									</tr>
									<tr>
									      <td class="theme-bg-light">varchar / text</td>
									      <td>String</td>
									</tr>
									<tr>
									    <td class="theme-bg-light">bool</td>
									    <td>Boolean</td>
									</tr>
									<tr>
									    <td class="theme-bg-light">int2</td>
									    <td>Short</td>
									</tr>
									<tr>
									    <td class="theme-bg-light">int4</td>
									    <td>Int</td>
									</tr>
									<tr>
									    <td class="theme-bg-light">int8</td>
									    <td>Long</td>
									</tr>
									<tr>
									    <td class="theme-bg-light">float4</td>
									    <td>Float</td>
									</tr>
									<tr>
									    <td class="theme-bg-light">float8</td>
									    <td>Double</td>
									</tr>
									<tr>
									    <td class="theme-bg-light">numeric</td>
									    <td>BigDecimal</td>
									</tr>
                  <tr>
                      <td class="theme-bg-light">time</td>
                      <td>java.sql.Time</td>
                  </tr>
									<tr>
									    <td class="theme-bg-light">date</td>
									    <td>java.sql.Date</td>
									</tr>
									<tr>
									    <td class="theme-bg-light">timestamp</td>
									    <td>java.sql.Timestamp</td>
									</tr>
                  <tr>
                      <td class="theme-bg-light">uuid</td>
                      <td>java.util.UUID</td>
                  </tr>
                  <tr>
                      <td class="theme-bg-light">jsonb</td>
                      <td>kuzminki.api.Jsonb(value: String)</td>
                  </tr>
								</tbody>
							</table>
						</div>
          </section>

          <section class="docs-section" id="item-15-2">
						<h2 class="section-heading">Operators</h2>
						<div class="table-responsive my-4">
							<table class="table table-bordered">
								<tbody>
								    <tr>
									    <th>Operator</th>
									    <th>Alternative</th>
									    <th>Cache</th>
									    <th>Type</th>
									</tr>
									<tr>
									    <td>===</td>
									    <td>matches</td>
									    <td>oprEq</td>
									    <td>Any</td>
									</tr>
									<tr>
									    <td>!==</td>
									    <td>not</td>
									    <td>oprNot</td>
									    <td>Any</td>
									</tr>
									<tr>
									    <td>></td>
									    <td>gt</td>
									    <td>oprGt</td>
									    <td>Numbers and time</td>
									</tr>
									<tr>
									    <td><</td>
									    <td>lt</td>
									    <td>oprLt</td>
									    <td>Numbers and time</td>
									</tr>
									<tr>
									    <td>>=</td>
									    <td>gte</td>
									    <td>oprGte</td>
									    <td>Numbers and time</td>
									</tr>
									<tr>
									    <td><=</td>
									    <td>lte</td>
									    <td>oprLte</td>
									    <td>Numbers and time</td>
									</tr>
									<tr>
									    <td>~</td>
									    <td>reMatch</td>
									    <td>oprReMatch</td>
									    <td>String</td>
									</tr>
									<tr>
									    <td>~*</td>
									    <td>reIMatch</td>
									    <td>oprReIMatch</td>
									    <td>String</td>
									</tr>
									<tr>
									    <td>!~</td>
									    <td>reNotMatch</td>
									    <td>oprNotReMatch</td>
									    <td>String</td>
									</tr>
									<tr>
									    <td>!~*</td>
									    <td>reNotIMatch</td>
									    <td>oprNotIReMatch</td>
									    <td>String</td>
									</tr>
									<tr>
									    <td></td>
									    <td>like</td>
									    <td>oprLike</td>
									    <td>String</td>
									</tr>
									<tr>
									    <td></td>
									    <td>startsWith</td>
									    <td>oprStartsWith</td>
									    <td>String</td>
									</tr>
									<tr>
									    <td></td>
									    <td>endsWith</td>
									    <td>oprEndsWith</td>
									    <td>String</td>
									</tr>
									<tr>
									    <td></td>
									    <td>similarTo</td>
									    <td>oprSimilarTo</td>
									    <td>String</td>
									</tr>
									<tr>
									    <td></td>
									    <td>isNull</td>
									    <td></td>
									    <td>Any</td>
									</tr>
									<tr>
									    <td></td>
									    <td>isNotNull</td>
									    <td></td>
									    <td>Any</td>
									</tr>
									<tr>
									    <td></td>
									    <td>in</td>
									    <td></td>
									    <td>Any</td>
									</tr>
									<tr>
									    <td></td>
									    <td>notIn</td>
									    <td></td>
									    <td>Any</td>
									</tr>
                  <tr>
                      <td></td>
                      <td>has</td>
                      <td>oprHas</td>
                      <td>Array</td>
                  </tr>
                  <tr>
                      <td></td>
                      <td>hasNot</td>
                      <td>oprHasNot</td>
                      <td>Array</td>
                  </tr>
                  <tr>
                      <td></td>
                      <td>overlap</td>
                      <td>oprOverlap</td>
                      <td>Array</td>
                  </tr>
                  <tr>
                      <td></td>
                      <td>overlapNot</td>
                      <td>oprOverlapNot</td>
                      <td>Array</td>
                  </tr>
                  <tr>
                      <td>@></td>
                      <td>contains</td>
                      <td>oprContains</td>
                      <td>Jsonb</td>
                  </tr>
                  <tr>
                      <td><@</td>
                      <td>containedBy</td>
                      <td>oprContainedBy</td>
                      <td>Jsonb</td>
                  </tr>
                  <tr>
                      <td>?</td>
                      <td>exists</td>
                      <td>oprExists</td>
                      <td>Jsonb</td>
                  </tr>
                  <tr>
                      <td>?|</td>
                      <td>existsAny</td>
                      <td>oprExistsAny</td>
                      <td>Jsonb</td>
                  </tr>
                  <tr>
                      <td>?&</td>
                      <td>existsAll</td>
                      <td>oprExistsAll</td>
                      <td>Jsonb</td>
                  </tr>
								</tbody>
							</table>
						</div>
          </section>

          <section class="docs-section" id="item-15-3">
						<h2 class="section-heading">Update operators</h2>
						<div class="table-responsive my-4">
							<table class="table table-bordered">
								<tbody>
								    <tr>
									    <th>Operator</th>
                      <th>Alternative</th>
									    <th>Cache operator</th>
                      <th>Type</th>
									</tr>
									<tr>
									    <td>==></td>
                      <td>set</td>
									    <td>modSet</td>
                      <td>Any</td>
									</tr>
									<tr>
									    <td>+=</td>
                      <td>inc</td>
									    <td>modInc</td>
                      <td>Numbers</td>
									</tr>
									<tr>
									    <td>-=</td>
                      <td>dec</td>
									    <td>modDec</td>
                      <td>Numbers</td>
									</tr>
                  <tr>
                      <td>:=</td>
                      <td>prepend</td>
                      <td>modPrepend</td>
                      <td>Array</td>
                  </tr>
                  <tr>
                      <td>+=</td>
                      <td>append</td>
                      <td>modAppend</td>
                      <td>Array</td>
                  </tr>
                  <tr>
                      <td>-=</td>
                      <td>remove</td>
                      <td>modRemove</td>
                      <td>Array</td>
                  </tr>
                  <tr>
                      <td>+=</td>
                      <td>update</td>
                      <td>modUpdate</td>
                      <td>Jsonb</td>
                  </tr>
                  <tr>
                      <td>-=</td>
                      <td>delKey</td>
                      <td>modDelKey</td>
                      <td>Jsonb</td>
                  </tr>
                  <tr>
                      <td>-=</td>
                      <td>delKey</td>
                      <td>modDelIndex</td>
                      <td>Jsonb</td>
                  </tr>
                  <tr>
                      <td>#-=</td>
                      <td>delPath</td>
                      <td>modDelPath</td>
                      <td>Jsonb</td>
                  </tr>
								</tbody>
							</table>
						</div>
          </section>
        </article>

		    <footer class="footer">
			    <div class="container text-center py-5">
		        <small class="copyright">Template Copyright &copy; <a href="https://themes.3rdwavemedia.com/" target="_blank">3rd Wave Media</a></small>
		        <ul class="social-list list-unstyled pt-4 mb-0">
				    	<li class="list-inline-item">
				    		<a href="https://github.com/karimagnusson/kuzminki-zio" target="_blank">
				    			<i class="fab fa-github fa-fw"></i>
				    		</a>
				    	</li> 
		        </ul>
			    </div>
		    </footer>
	    </div>
    </div>
  </div>
   
       
    <!-- Javascript -->          
    <script src="assets/plugins/popper.min.js"></script>
    <script src="assets/plugins/bootstrap/js/bootstrap.min.js"></script>  
    
    
    <!-- Page Specific JS -->
    <script src="assets/plugins/smoothscroll.min.js"></script>
    <script defer src="assets/js/pgsql.min.js"></script>
    <script defer src="assets/js/sql.min.js"></script>
   	<!--<script defer src="assets/js/highlight.min.js"></script>-->
   	<script defer src="assets/js/scala.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
    <script src="assets/js/highlight-custom.js"></script>
    <script src="assets/plugins/simplelightbox/simple-lightbox.min.js"></script>      
    <script src="assets/plugins/gumshoe/gumshoe.polyfills.min.js"></script> 
    <script src="assets/js/docs.js"></script> 

</body>
</html> 

