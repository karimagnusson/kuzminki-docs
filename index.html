<!DOCTYPE html>
<html lang="en"> 
<head>
  <title>Kuzminki</title>
  
  <!-- Meta -->
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <meta name="description" content="Kuzminki-zio access library for PostgreSQL and ZIO">
  <link rel="shortcut icon" href="favicon.ico"> 
  
  <!-- Google Font -->
  <link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700&display=swap" rel="stylesheet">
  
  <!-- FontAwesome JS-->
  <script defer src="assets/fontawesome/js/all.min.js"></script>
  
  <!-- Plugins CSS -->
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.2/styles/monokai-sublime.min.css">
  <link rel="stylesheet" href="assets/plugins/simplelightbox/simple-lightbox.min.css">
  <!--<link rel="stylesheet" href="assets/css/atom-one-light.min.css">-->
  <!--<link rel="stylesheet" href="assets/css/monokai-sublime.min.css">-->

  <!-- Theme CSS -->  
  <link id="theme-style" rel="stylesheet" href="assets/css/theme.css">
  <style>
  	pre {margin: 0 !important; padding: 0 !important;}
  	.docs-code-block {
  		margin-top: 0 !important;
  		margin-bottom: 0 !important;
  		padding-top: 0 !important;
  		padding-bottom: 0 !important;
  	}
  	.docs-article {padding: 1rem 2rem;}
  	.docs-article .docs-section {padding-top: 1rem; padding-bottom: 0;}
  	a {color: #6a5acd;}
  	a:hover {color: #7b68ee;}
  	.nav-item.active .nav-link {color: #663399;}
		.theme-icon-holder {background: #e6e6fa; color: #663399;}
		.docs-nav .nav-item .nav-link:before {background-color: #e6e6fa;}
		.docs-nav .nav-item.active .nav-link {color: #663399;}
		.docs-nav .nav-item.active .nav-link .theme-icon-holder {background: #663399; color: #dcd0ff;}
		.docs-nav .nav-item.active .nav-link:before {background-color: #663399;}
		.social-list li {background: #ffffff;}
		.social-list li a {color: #6a5acd; background: #ffffff;}
		code {background: #e6e6fa;}
		/*.site-logo .logo-text {color: #f92672;}/*
	</style>

  <script type="text/javascript">
    var req = new XMLHttpRequest();
    req.open('GET', '/hit');
    req.send();
  </script>

	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-JW532LFCYV"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-JW532LFCYV');
	</script>
</head> 

<body class="docs-page">    
  <header class="header fixed-top">	    
    <div class="branding docs-branding">
      <div class="container-fluid position-relative py-2">
        <div class="docs-logo-wrapper">
					<button id="docs-sidebar-toggler" class="docs-sidebar-toggler docs-sidebar-visible me-2 d-xl-none" type="button">
            <span></span>
            <span></span>
            <span></span>
          </button>
          <div class="site-logo">
          	<a class="navbar-brand" href="index.html">
          		<!--<img class="logo-icon me-2" src="assets/images/coderdocs-logo.svg" alt="logo">-->
          		<span class="logo-text">Kuzminki</span>
          	</a>
          </div>    
        </div><!--//docs-logo-wrapper-->
        <div class="docs-top-utilities d-flex justify-content-end align-items-center">
					<ul class="social-list list-inline mx-md-3 mx-lg-5 mb-0 d-none d-lg-flex">
						<li class="list-inline-item">
							<a href="https://github.com/karimagnusson/kuzminki-zio" target="_blank"><i class="fab fa-github fa-fw"></i></a>
						</li>
						<li class="list-inline-item">
              <a href="https://twitter.com/kuzminki_lib" target="_blank"><i class="fab fa-twitter fa-fw"></i></a>
            </li>
            <li class="list-inline-item">
              <a href="https://discord.com/channels/629491597070827530/1063139826636963931" target="_blank"><i class="fab fa-discord fa-fw"></i></a>
            </li>
          </ul><!--//social-list-->
        </div><!--//docs-top-utilities-->
      </div><!--//container-->
    </div><!--//branding-->
  </header><!--//header-->
    
    
    <div class="docs-wrapper">
	    <div id="docs-sidebar" class="docs-sidebar">
		    <nav id="docs-nav" class="docs-nav navbar">
			    <ul class="section-items list-unstyled nav flex-column pb-3">
				    
            <li class="nav-item section-title"><a class="nav-link scrollto" href="#section-1"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Introduction</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-1-1">About</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-1-2">Installation</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-1-3">Example</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-1-4">Results</a></li>
				    
            <li class="nav-item section-title"><a class="nav-link scrollto" href="#section-2"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Connecting</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-2-1">Config</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-2-2">Layer</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-2-3">Split connection</a></li>
				    
            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-3"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Model</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-3-1">Creating a model</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-3-2">Custom methods</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-3-3">Create model instance</a></li>
				    
            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-4"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Select</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-4-1">Select query</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-4-2">Row as case class</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-4-3">Row as Seq</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-4-4">Row as JSON</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-4-5">Where</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-4-6">GROUP BY / HAVING</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-4-7">AND / OR</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-4-8">Optional conditions</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-4-9">Distinct</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-4-10">Nested query</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-4-11">Pages</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-4-12">Cache</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-4-13">Cached with WHERE</a></li>
				    
            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-5"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Joins</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-5-1">Join</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-5-2">Join types</a></li>
				    
            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-6"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Insert</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-6-1">Basic insert</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-6-2">Insert case class</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-6-3">Insert returning</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-6-4">Insert on conflict do nothing</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-6-5">Upsert</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-6-6">Insert where not exists</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-6-7">Insert from select</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-6-8">Insert many</a></li>
			    	
            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-7"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Update</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-7-1">Update statement</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-7-2">Update returning</a></li>
				    
            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-8"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Delete</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-8-1">Delete statement</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-8-2">Delete returning</a></li>

            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-9"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Null values</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-9-1">Null values in results</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-9-2">Insert and update null values</a></li>
				    
            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-10"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Aggregation</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-10-1">Count</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-10-2">Avg Max Min</a></li>

            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-11"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Streaming</a></li>
            
            <li class="nav-item"><a class="nav-link scrollto" href="#item-11-1">Stream from the database</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-11-2">Streaming into the database</a></li>

            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-12"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Transaction</a></li>

            <li class="nav-item"><a class="nav-link scrollto" href="#item-12-1">Execute multiple operations</a></li>

            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-13"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Debug</a></li>
            
            <li class="nav-item"><a class="nav-link scrollto" href="#item-13-1">Print the query</a></li>

            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-14"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Fields</a></li>
            
            <li class="nav-item"><a class="nav-link scrollto" href="#item-14-1">Jsonb field</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-14-2">Array field</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-14-3">Timestamp, Date, Time</a></li>

            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-15"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Functions</a></li>
            
            <li class="nav-item"><a class="nav-link scrollto" href="#item-15-1">Postgres functions</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-15-3">Create functions</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-15-4">Available functions</a></li>

            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-16"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Raw statements</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-16-1">Select</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-16-2">Operation</a></li>
				    
            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-17"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Data types and operators</a></li>
				    
            <li class="nav-item"><a class="nav-link scrollto" href="#item-17-1">Data types</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-17-2">Operators</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-17-3">Update operators</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#item-17-4">Modifiers</a></li>
          
          </ul>
		    </nav>
	    </div>

      <!-- Introduction -->

	    <div class="docs-content">
		    <div class="container">
			    <article class="docs-article" id="section-1">
				    <header class="docs-header">
					    <h1 class="docs-heading">Introduction <span class="docs-time">Last updated: 2022-12-29</span></h1>
					    <section class="docs-intro">
						  	<p>Kuzminki is feature-rich query builder and access library for PostgreSQL written in Scala.</p>

								<p>It is available with integration for <a href="https://github.com/karimagnusson/kuzminki-zio" target="_blank">ZIO 1</a> and <a href="https://github.com/karimagnusson/kuzminki-zio-2" target="_blank">ZIO 2</a> and a <a href="https://github.com/karimagnusson/kuzminki-ec" target="_blank">version</a> that relies only on Scala ExecutionContext.The API follows the logic of SQL statements. As a result the code is easy to read and memorise while the resulting SQL statement is predictable. It is as type-checked as possible and does not use any wild-card types resulting in confusing errors.</p>

                <p>Features:</p>
                <ul>
                  <li>Cached queries, meaning that the SQL string is built only once, for improved performance and re-usability.</li>
                  <li>Streaming from and to the database</li>
                  <li>Extensive support for JSONB fields</li>
                  <li>Support for Array fields</li>
                  <li>Rich support for timestamp fields</li>
                  <li>Support for sub-queries</li>
                  <li>Support for transactions</li>
                </ul>

                <h5>Kuzminki projects on GitHub</h5>

                <p>On Github for ZIO 1<a href="https://github.com/karimagnusson/kuzminki-zio" target="_blank">
                  https://github.com/karimagnusson/kuzminki-zio
                </a></p>

                <p>On Github for ZIO 2<a href="https://github.com/karimagnusson/kuzminki-zio-2" target="_blank">
                  https://github.com/karimagnusson/kuzminki-zio-2
                </a></p>

                <p>On Github for EC<a href="https://github.com/karimagnusson/kuzminki-ec" target="_blank">
                  https://github.com/karimagnusson/kuzminki-ec
                </a></p>
						</section>
					</header>

          <section class="docs-section" id="item-1-1">
            <h2 class="section-heading">About</h2>
            <p>Kuzminki is feature-rich query builder and access library for PostgreSQL written in Scala. The approach of this library is to write SQL statements in Scala with the same structure as SQL is written. Rather than having the API natural to Scala logic, for example similar to how you work with collections, this approach seeks to make the Scala code as similar to the resulting SQL statement as possible. The goal of this approach is to make it easy to read the code and understand the resulting SQL statement. It should also make the API intuitive and easy to memorise. With this approach, it becomes practical to write quite complicated queries while still being able to understand what they do. For example subqueries and queries where column values are modified. With a different approach, the user would have to learn the libraries own unique logic. But since the logic of SQL is already known, such complexity becomes practical. With a feature-rich API, the user can find solutions and avoid writing raw SQL statements that are not checked by the compiler. The goal of this project is to offer a productive and readable API to work with Postgresql and take advantage of its many features.</p>
            <h5>Features</h5>
            <p>Kuzminki supports jsonb and array fields. When doing insert, update or delete, it offers one or more column values to be returned. It offers many options for searching and returning datetime column values. It supports subqueries, both as a condition in a search and collect values to be returned to the client. Transactions are supported, both as a way to do bulk-operations and to do multiple different operations. Data can be streamed to and from the database. Rows can be delivered to the client as, tuples, case classes or vectors. Data for insert can be a tuple or a case class. Types are checked as much as possible and wild-card types that result in unclear errors are not used. Kuzminki comes with native support for ZIO as a layer.</p>
            <h5>JSON</h5>
            <p>Postgresql comes with a jsonb field to store and query data in JSON format. Being able to take advantage of the jsonb field opens up great flexibility in organizing your data. You can work with structured and unstructured data to get the best of both worlds. Kuzminki offers extensive support for querying and updating jsonb fields. Also, Kuzminki offers the ability to return rows as JSON strings. This can be useful when, for example, you need to service JSON directly to the client you can do so without having to transform the data. You can organise how your object is formed from the table columns. For example if you need some columns to be in a nested object. If you need to create a big object from multiple tables, you can do so with a single query using subqueries. Take a look at the <a href="https://github.com/karimagnusson/kuzminki-zhttp-demo">zio-http demo project</a> for examples of these features.</p>
            <h5>Performance</h5>
            <p>Statements can be cached for better performance and reusability. This means that the SQL string is created only once. Execution time should be the same as running a raw statement with JDBC. All statements can be cached except for SELECT statements with optional WHERE arguments.</p>
            <h5>Only Postgres</h5>
            <p>Kuzminki supports only Postgresql. It could be adapted for use with other databases if there is interest in that. But given that it has support for many postgres specific features, support for another database would require itâ€™s own project rather than a size fits all approach. Therefore, at the moment the goal is to deliver a good library for Postgres. That being said, there are other Postgres compatible databases that work with Kuzminki. For example CockroachDB. For those looking to scale up, it might be a good choice.</p>
            </br>
          </section>

					<section class="docs-section" id="item-1-2">
						<h2 class="section-heading">Installation</h2>
						<h5>For ZIO 1</h5>
            <div class="docs-code-block">
							<pre class="rounded"><code class="hljs">libraryDependencies += "io.github.karimagnusson" % "kuzminki-zio" % "0.9.5-RC4"</code></pre>
						</div>
            <h5 style="margin-top: 10px;">For ZIO 2</h5>
            <div class="docs-code-block">
              <pre class="rounded"><code class="hljs">libraryDependencies += "io.github.karimagnusson" % "kuzminki-zio-2" % "0.9.5-RC4"</code></pre>
            </div>
            <h5 style="margin-top: 10px;">For EC</h5>
            <div class="docs-code-block">
              <pre class="rounded"><code class="hljs">libraryDependencies += "io.github.karimagnusson" % "kuzminki-ec" % "0.9.5-RC4"</code></pre>
            </div>

            <p> </p>
            <p>This documentation is for version 0.9.5-RC4. If you need an older version of this documentation:</p>
            <div>
              <a href="0.9.4-RC5.html">0.9.4</a>
            </div>
            <div>
              <a href="0.9.4-RC4.html">0.9.4-RC5</a>
            </div>
            <div>
              <a href="0.9.4-RC3.html">0.9.4-RC3</a>
            </div>
            <div>
              <a href="0.9.4-RC1.html">0.9.4-RC1</a>
            </div>
            <div>
              <a href="0.9.2.html">0.9.2</a>
            </div>
					</section>

				  <section class="docs-section" id="item-1-3">
						<h2 class="section-heading">Example</h2>
            <p>This example is for ZIO. For ZIO 2 refer to the respective github pages.
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">import zio._
import zio.console._
import zio.blocking._
import kuzminki.api._

object ExampleApp extends zio.App {

  class Client extends Model("client") {
    val id = column[Int]("id")
    val username = column[String]("username")
    val age = column[Int]("age")
    def all = (id, username, age)
  }

  val client = Model.get[Client]

  val job = for {
    _ <- sql
      .insert(client)
      .cols2(t => (t.username, t.age))
      .values(("Joe", 35))
      .run
    
    _ <- sql
      .update(client)
      .set(_.age ==> 24)
      .where(_.id === 4)
      .run
    
    _ <- sql.delete(client).where(_.id === 7).run
    
    clients <- sql
      .select(client)
      .cols3(_.all)
      .where(_.age > 25)
      .limit(5)
      .run
    
    _ <- ZIO.foreach(clients) {
      case (id, username, age) =>
        putStrLn(s"$id $username $age")
    }
  } yield ()

  val dbConfig = DbConfig.forDb("company")
  val dbLayer = Kuzminki.layer(dbConfig)

  override def run(args: List[String]): ZIO[ZEnv, Nothing, ExitCode] = {
    job.provideCustomLayer(dbLayer).exitCode
  }
}</code>
							</pre>
						</div>
					</section>

				  <section class="docs-section" id="item-1-4">
          	<h2 class="section-heading">Results</h2>

            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">// query
val stm = sql.select(client).cols3(_.all).where(_.age > 25).limit(5)
stm.run: List[T]
stm.runHead: T
stm.runHeadOpt: Option[T]

// row as type (cecked by the compiler)
stm.runType[MyType]: List[MyType]
stm.runHeadType[MyType]: MyType
stm.runHeadOptType[MyType]: Option[MyType]

// modify row
implicit val toMyType: SomeRow => MyType = row => //...
stm.runAs[MyType]: List[MyType]
stm.runHeadAs[MyType]: MyType
stm.runHeadOptAs[MyType]: Option[MyType]

// operation
val stm = sql.update(client).set(_.age ==> 24).where(_.id === 4)
stm.run: Unit
stm.runNum: Int</code>
              </pre>
            </div>
          </section>
        </article>

        <!-- Connecting to the database -->

				<article class="docs-article" id="section-2">
				  <header class="docs-header">
				    <h1 class="docs-heading">Connecting to the database</h1>
					</header>
					
					<section class="docs-section" id="item-2-1">
						<h2 class="section-heading">Config</h2>
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">val dbConfig = DbConfig
  .forDb("{DB-NAME}")
  .withMaxPoolSize(10) // default = 10
  .withMinPoolSize(4)  // default = 4
  .withHost("{HOST}")  // default = localhost
  .withPort("{PORT}")  // default = 5432
  .withUser("{USER}}")
  .withPassword("{PASSWORD}")
  .withOptions(Map(...))</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-2-2">
          	<h2 class="section-heading">Layer</h2>
          	<p>Create a layer to make the driver instance accessable under <code>Has[Kuzminki]</code></p>
            <p>For ZIO 1</p>
            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">object MyApp extends zio.App {
  val job = // ...
  val dbLayer = Kuzminki.layer(DbConfig.forDb("company"))

  override def run(args: List[String]): ZIO[ZEnv, Nothing, ExitCode] = {
    job.provideCustomLayer(dbLayer).exitCode
  }
}</code>
            	</pre>
            </div>
            <p>For ZIO 2</p>
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">object MyApp extends ZIOAppDefault {
  // ...
  def run = job.provide(dbLayer)
}</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-2-3">
          	<h2 class="section-heading">Split connection</h2>
          	<p>If you wish to have two connection pools, one for SELECT and another for INSERT, UPDATE, DELETE, you can use <code>layerSplit</code>. To create an instance rather than a Layer, use <code>createSplit</code>.</p>
            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">// for .query .queryHead .queryHeadOpt
val getConfig = DbConfig.forDb("company")

// for .exec .execNum
val setConfig = DbConfig.forDb("company")

val dbLayer = Kuzminki.layerSplit(getConfig, setConfig)</code>
            	</pre>
            </div>

					</section><!--//section-->
				</article>

        <!-- Model -->

				<article class="docs-article" id="section-3">
				  <header class="docs-header">
				    <h1 class="docs-heading">Model</h1>
					</header>
					
					<section class="docs-section" id="item-3-1">
						<h2 class="section-heading">Creating a model</h2>
						<p>Column types are listed under <a href="#item-17-1">Data types</a></p>
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">import kuzminki.api._
import java.sql.Timestamp

class User extends Model("user_profile") {
  val id = column[Int]("id")
  val username = column[String]("username")
  val email = column[String]("email")
  val name = column[String]("name")
  val age = column[Int]("age")
  val gender = column[String]("gender")
  val country = column[String]("country")
  val city = column[String]("city")
  val discount = column[Int]("discount")
  val isActive = column[Boolean]("is_active")
  val created = column[Timestamp]("created")
}

Model.register[User]</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-3-2">
          	<h2 class="section-heading">Custom methods</h2>
          	<p>You can create custom methods to access columns that you regularly use.</p>
            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">class Customer extends Model("customer") {
  val id = column[Int]("id")
  val userId = column[Int]("user_id")
  val spending = column[Int]("spending")
  def all = (id, userId, spending)
}</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-3-3">
          	<h2 class="section-heading">Create a model instance</h2>
          	<p><code>Model.register[User]</code> creates an instance of the model for later use and makes sure there is only one instance of the model. <code>Model.get[User]</code> gets an existing instance of the model. If it does not exist, it is created.</p>
            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">Model.register[User]
// ...
val user = Model.get[User]</code>
            	</pre>
            </div>
          </section>
          </article>

          <!-- Select -->

			    <article class="docs-article" id="section-4">
				    <header class="docs-header">
					    <h1 class="docs-heading">Select</h1>
					    <section class="docs-intro">
						    
						</section><!--//docs-intro-->
				    </header>
				    <section class="docs-section" id="item-4-1">
							<h2 class="section-heading">Select query</h2>
							<p>You select the columns as tuple of model columns. The query will return tuple of the column types. In this case <code>Seq[Tuple2[Int, String]]</code>. If you need more than 22 columns you can use <code>colsSeq</code> or <code>colsType</code>. To order by <code>ASC</code> rather than <code>DESC</code> use <code>orderBy(_.age.asc)</code>.
						 	<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">sql
  .select(user)
  .cols2(t => (
    t.id,
    t.username
  ))
  .where(t => Seq(
    t.gender === "f",
    t.age > 25
  ))
  .orderBy(_.age.desc)
  .limit(10)
  .run</code>
            	</pre>
            </div>

            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-pgsql hljs">SELECT
  "id",
  "username"
FROM "user_profile"
WHERE "gender" = 'f'
AND "age" > 25
ORDER BY "age" DESC
LIMIT 10</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-2">
          <h2 class="section-heading">Row as case class</h2>
          <div class="docs-code-block">
            <pre class="rounded">
              <code class="language-scala hljs">case class SimpleUser(id: Int, username: String, email: String)

sql
  .select(user)
  .cols3(t => (
    t.id,
    t.username,
    t.email
  ))
  .where(_.age < 25)
  .runType[SimpleUser]
  // returns List[SimpleUser]</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-3">
          <h2 class="section-heading">Row as Seq</h2>
          <div class="docs-code-block">
            <pre class="rounded">
              <code class="language-scala hljs">sql
  .select(user)
  .colsSeq(t => Seq(
    t.id,
    t.username,
    t.email
  ))
  .where(_.age < 25)
  .run
  // returns List[Vector[Any]]</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-4">
            <h2 class="section-heading">Row as JSON</h2>
            <p>Get the row as a JSON string.</p>
            <div class="docs-code-block">
              
              <pre class="rounded">
                <code class="language-scala hljs">sql
  .select(user)
  .colsJson(t => Seq(
    t.id,
    t.username
  ))
  .where(_.id === 5)
  .runHead
  // returns {"id": 5, "username": "Joe"}</code>
              </pre>

              <p>Pick a name for columns and create a nested object.</p>

              <pre class="rounded">
                <code class="language-scala hljs">.colsJson(t => Seq(
  "id" -> t.id,
  t.username.as("username"),
  Fn.json(Seq(
    t.country,
    t.city
  )).as("location")
))
// returns {"id": 5, "username": "Joe", "location": {"country": "IT", "city": "Rome"}}</code>
              </pre>

              <p>Result with a nested array from subquery.</p>

              <pre class="rounded">
                <code class="language-scala hljs">.colsJson(t => Seq(
  t.id,
  t.username,
  sql
    .select(travels)
    .colsJson(s => Seq(
      s.country,
      s.year
    ))
    .where(s.userId <=> t.id)
    .orderBy(_.year.desc)
    .asColumn // if you need the first object instead of an array, you can use .first after .asColumn
    .as("travels")
))</code>
              </pre>

            </div>

            <p>Get the result as JSON, using your favorite JSON library.</p>

            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">// See PlayJsonLoader below
implicit val loadJson: Seq[Tuple2[String, Any]] => JsValue = data => PlayJsonLoader.load(data)

sql
  .select(user)
  .colsNamed(t => Seq(
    t.id,        // Column name is used as a key.
    t.username,  // If you want a different key:
    t.email      // ("user_id"  -> t.id)
  ))
  .where(_.age < 25)
  .runAs[JsValue]
  // returns List[JsValue]</code>
              </pre>
            </div>

            <p>Write something along these lines to use the JSON library of your choosing.</p>

            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">import java.util.UUID
import java.sql.Time
import java.sql.Date
import java.sql.Timestamp
import play.api.libs.json._
import kuzminki.api.Jsonb

object PlayJsonLoader {

  val toJsValue: Any => JsValue = {
    case v: String      => JsString(v)
    case v: Boolean     => JsBoolean(v)
    case v: Short       => JsNumber(v)
    case v: Int         => JsNumber(v)
    case v: Long        => JsNumber(v)
    case v: Float       => JsNumber(v)
    case v: Double      => JsNumber(v)
    case v: BigDecimal  => JsNumber(v)
    case v: Time        => Json.toJson(v)
    case v: Date        => Json.toJson(v)
    case v: Timestamp   => Json.toJson(v)
    case v: UUID        => JsString(v.toString)
    case v: Jsonb       => Json.parse(v.value)
    case v: Option[_]   => v.map(toJsValue).getOrElse(JsNull)
    case v: Seq[_]      => JsArray(v.map(toJsValue))
    case v: JsValue     => v
    case _              => throw new Exception("Cannot convert to JsValue")
  }

  def load(data: Seq[Tuple2[String, Any]]): JsValue = {
    JsObject(data.map(p => (p._1, toJsValue(p._2))))
  }
}</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-5">
          	<h2 class="section-heading">Where</h2>
          	<p>Refer to <a href="#item-17-2">Operators</a> for a list of operators.</p>
            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">.where(_.id > 100)

.where(t => Seq(
  t.gender === "f",
  t.age > 25
))</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-6">
            <h2 class="section-heading">GROUP BY / HAVING</h2>
            <p>Refer to <a href="#item-17-2">Operators</a> for a list of operators.</p>
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">sql
.select(user)
.cols2(t => (
  t.gender,
  Agg.avg(t.age)
))
.where(_.age > 0)
.groupBy(_.gender)
.having(_.gender !== "")
.orderBy(t => Agg.avg(t.age).desc)
.run</code>
              </pre>

              <pre class="rounded">
                <code class="language-pgsql hljs">SELECT "gender", avg("age")::numeric
FROM "user_profile" WHERE "age" > 0
GROUP BY "gender"
HAVING "gender" != ''
ORDER BY avg("age")::numeric ASC
)</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-7">
          	<h2 class="section-heading">AND / OR</h2>
          	<p>
            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">import kuzminki.fn._

.where(t => Seq(
  t.age > 25,
  Or(
    t.country === "RU",
    t.country === "FR"
  )
))
// WHERE "age" > 25 AND ("country" == 'RU' OR "country" == 'FR')

.where(t => Or(
  And(
    t.country === "RU",
    t.city === "Moscow"
  ),
  And(
    t.country === "FR",
    t.city === "Paris"
  )
))
// WHERE ("country" == 'RU' AND "city" == 'Moscow') OR ("country" == 'FR' AND "city" == 'Paris')</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-8">
          	<h2 class="section-heading">Optional conditions</h2>
          	<p>Optional conditions for example from http GET request.</p>
            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">.whereOpt(_.id > Some(100))

.whereOpt(t => Seq(
  t.gender === None,
  t.age > Some(25)
))
// WHERE "age" > 25

.whereOpt(t => Seq(
  t.age > Some(25),
  Or.opt(
    t.country === Some("RU"),
    t.country === Some("FR")
  )
))
// WHERE "age" > 25 AND ("country" == 'RU' OR "country" == 'FR')</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-9">
            <h2 class="section-heading">Distinct</h2>
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">sql
  .select(user)
  .cols2(t => (
    t.username,
    t.age
  ))
  .distinct
  .all
  .orderBy(_.age.asc)
  .run</code>
              </pre>

              <pre class="rounded">
                <code class="language-pgsql hljs">SELECT DISTINCT "username", "age"
FROM "user_profile"
ORDER BY "age" ASC
)</code>
              </pre>

              <pre class="rounded">
                <code class="language-scala hljs">sql
  .select(user)
  .cols2(t => (
    t.username,
    t.age
  ))
  .distinctOn(_.age)
  .all
  .orderBy(_.age.asc)
  .run</code>
              </pre>

              <p>DISTINCT ON</p>

              <pre class="rounded">
                <code class="language-pgsql hljs">SELECT DISTINCT ON ("age") "username", "age"
FROM "user_profile"
ORDER BY "age" ASC
)</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-10">
          	<h2 class="section-heading">Nested query</h2>
            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">class Newsletter extends Model("newsletter") {
  val email = column[String]("email")
  val isSubscribed = column[Boolean]("is_subscribed")
}

val newsletter = Model.get[Newsletter]

sql
  .select(user)
  .cols1(_.username)
  .where(_.email.in(
    sql
      .select(newsletter)
      .cols1(_.email)
      .where(_.isSubscribed === true)
  ))
  .run</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">SELECT "username"
FROM "user_profile"
WHERE "email" = ANY(
  SELECT "email"
  FROM "newsletter"
  WHERE "is_subscribed" = true
)</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-11">
            <h2 class="section-heading">Pages</h2>
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">val pages = sql
  .select(user)
  .cols3(t => (
    t.id,
    t.firstName,
    t.lastName)
  ))
  .orderBy(_.id.asc)
  .asPages(10) // 10 rows on page

val job = for {
  next  <- pages.next
  page3 <- pages.page(3)
} yield (next, page3)</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-4-12">
          	<h2 class="section-heading">Cache</h2>
          	<p>For increased performance and reusability queries can be cached. The SQL string will be created only once and you get the same performance as you get with raw queries.</p>
            <div class="docs-code-block">

							<pre class="rounded">
								<code class="language-scala hljs">val stm = sql
  .select(user)
  .cols1(_.username)
  .all
  .orderBy(_.age.asc)
  .pickWhere2(t => (
    t.country.use === Arg,
    t.age.use > Arg
  ))
  .cache

stm.run(("CN", 25))</code>
            	</pre>

							<pre class="rounded">
								<code class="language-pgsql hljs">SELECT "username"
FROM "user_profile"
WHERE "country" = 'CN'
AND "age" > 25
ORDER BY "age" ASC</code>
            	</pre>
              <p>Chche a query with no arguments.</p>
              <pre class="rounded">
                <code class="language-scala hljs">val stm = sql
  .select(user)
  .col2(t => (
    t.username,
    t.created
  ))
  .all
  .orderBy(_.created.desc)
  .cache

stm.run</code>
              </pre>

              <p>Cache nested query.</p>

              <pre class="rounded">
                <code class="language-scala hljs">val stm = sql
  .select(user)
  .cols1(_.username)
  .all
  .pickWhere(t = (
    t.age.use > Arg,
    t.email.use.in(
      sql
        .select(newsletter)
        .cols1(_.email)
        .all
        .pickWhere1(_.isActive.use === Arg)
    )
  ))
  .cache

stm.run(25, true)</code>
              </pre>

              <pre class="rounded">
                <code class="language-pgsql hljs">SELECT "username" FROM "user_profile"
WHERE "age" > 25
AND "email" = ANY(
  SELECT "a"."email"
  FROM "client" "a"
  WHERE "a"."is_active" > true
)</code>
              </pre>
              
              <p>Cache WHERE with HAVING</p>

              <pre class="rounded">
                <code class="language-scala hljs">val stm = sql
  .select(user)
  .cols2(t => (
    t.gender,
    Agg.avg(t.age)
  ))
  .all
  .groupBy(_.gender)
  .having(_.gender !== "")
  .orderBy(t => Agg.avg(t.age).desc)
  .pickWhere1(_.gender.use > Arg)
  .cache

stm.run(18)</code>
              </pre>
              <pre class="rounded">
                <code class="language-pgsql hljs">SELECT "gender", avg("age")::numeric
FROM "user_profile" WHERE "age" > 18
GROUP BY "gender"
HAVING "gender" != ''
ORDER BY avg("age")::numeric ASC</code>
              </pre>

            </div>
          </section>

          <section class="docs-section" id="item-4-13">
          	<h2 class="section-heading">Cached with WHERE</h2>
            <p>You can use normal WHERE conditions with cached queries.</p>
            <div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">val stm = sql
  .select(user)
  .cols1(_.username)
  .where(_.age > 25)
  .orderBy(_.age.asc)
  .pickWhere1(_.country.use === Arg)
  .cache

stm.run("CN")</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">SELECT "username"
FROM "user_profile"
WHERE "age" > 25
AND "country" = 'CN'
ORDER BY "age" ASC</code>
            	</pre>
            </div>
          </section>



        </article>

        <!-- Join -->

        <article class="docs-article" id="section-5">
			    <header class="docs-header">
				    <h1 class="docs-heading">Join</h1>
			    </header>
			    <section class="docs-section" id="item-5-1">
						<h2 class="section-heading">Select join</h2>
						<p>To do Joins you just put two model instances as arguments and the models will be accessable under <code>a</code> and <code>b</code></p>
					 	<div class="docs-code-block">
						<pre class="rounded">
							<code class="language-scala hljs">sql
  .select(user, customer)
  .cols3(t => (
    t.a.id,
    t.a.username,
    t.b.spending
  ))
  .joinOn(_.id, _.userId)
  .where(t => Seq(
    t.a.age > 25,
    t.b.spending > 1000
  ))
  .orderBy(_.b.spending.desc)
  .limit(10)
  .run
  // returns List[Tuple3[Int, String, Int]]</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">SELECT
  "a"."id",
  "a"."username",
  "b"."spending"
FROM "user_profile" "a"
INNER JOIN "customer" "b"
ON "a"."id" = "b"."user_id"
WHERE "a"."age" > 25
AND "b"."spending" > 1000
ORDER BY "b"."spending" DESC
LIMIT 10</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-5-2">
					<h2 class="section-heading">Join types</h2>
					<p>The following joins are available. Refer to the section <a href="#item-9-1">Null values</a> to avoid problems that may come up with joins.
					 <div class="docs-code-block">
						<pre class="rounded">
							<code class="language-scala hljs">.joinOn(_.id, _.userId) // INNER JOIN

.innerJoinOn(_.id, _.userId) // INNER JOIN

.leftJoinOn(_.id, _.userId) // LEFT JOIN

.leftOuterJoinOn(_.id, _.userId) // LEFT OUTER JOIN
 
.rightJoinOn(_.id, _.userId) // RIGHT JOIN

.rightOuterJoinOn(_.id, _.userId) // RIGHT OUTER JOIN

.fullOuterJoinOn(_.id, _.userId) // FULL OUTER JOIN

.crossJoin // CROSS JOIN</code>
            	</pre>
            </div>
          </section>

      	</article>

        <!-- Insert -->

				<article class="docs-article" id="section-6">
			    <header class="docs-header">
				    <h1 class="docs-heading">Insert</h1>
			    </header>
			    <section class="docs-section" id="item-6-1">
					<h2 class="section-heading">Basic insert</h2>
					<div class="docs-code-block">
						<pre class="rounded">
							<code class="language-scala hljs">sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .values(("bob", "bob@mail.com"))
  .run</code>
            </pre>
          </div>

<span>If you need to insert more than the tuple limit of 22.</span>

          <div class="docs-code-block">
            <pre class="rounded">
              <code class="language-scala hljs">sql
  .insert(user)
  .data(t => Seq(
    t.username ==> "bob",
    t.email ==> "bob@mail.com"
  ))
  .run</code>
            </pre>
          </div>

<span>For increased performance and reusability queries can be cached.</span>

          <div class="docs-code-block">
            <pre class="rounded">
              <code class="language-scala hljs">val stm = sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .cache

stm.run(("bob", "bob@mail.com"))</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">INSERT INTO "user_profile" ("username", "email") VALUES ('bob', 'bob@mail.com')</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-6-2">
          <h2 class="section-heading">Insert case class</h2>
          <div class="docs-code-block">
            <pre class="rounded">
              <code class="language-scala hljs">case class User(name: String, email: String)

val stm = sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .valuesType(User("Bob", "bob@mail.com"))
  .run

// cache
val stm = sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .cache

stm.run(User("Bob", "bob@mail.com"))
</code>
              </pre>
              <pre class="rounded">
                <code class="language-pgsql hljs">INSERT INTO "product" ("name", "price") VALUES ('Banana', 12.5)</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-6-3">
					<h2 class="section-heading">Insert returning</h2>
					<div class="docs-code-block">
						<pre class="rounded">
							<code class="language-scala hljs">sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .values(("bob", "bob@mail.com"))
  .returning3(t => (
    t.id,
    t.username,
    t.email
  ))
  .runHead

// cache
val stm = sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .returning3(t => (
    t.id,
    t.username,
    t.email
  ))
  .cache

stm.run(("bob", "bob@mail.com"))</code>
            	</pre>
							
              <pre class="rounded">
								<code class="language-pgsql hljs">INSERT INTO "user_profile"
("username", "email")
VALUES ('bob', 'bob@mail.com')
RETURNING
  "id",
  "username",
  "email"</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-6-4">
					  <h2 class="section-heading">Insert on conflict do nothing</h2>
					  <p>You can take advantage of <code>ON CONFLICT DO NOTHING</code> to avoid errors on columns with <code>UNIQUE</code> constraint.</p>
					  <div class="docs-code-block">
						  <pre class="rounded">
							  <code class="language-scala hljs">sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .values(("bob", "bob@mail.com"))
  .onConflictDoNothing
  .run

// cache
val stm = sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .onConflictDoNothing
  .cache

stm.run(("bob", "bob@mail.com"))</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">INSERT INTO "user_profile"
("username", "email")
VALUES ('bob', 'bob@mail.com')
ON CONFLICT DO NOTHING</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-6-5">
					<h2 class="section-heading">Upsert</h2>
					<p>The updated column has to be one of the columns you intend to insert.</p>
					<div class="docs-code-block">
						<pre class="rounded">
							<code class="language-scala hljs">sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .values(("bob", "bob@hotmail.com"))
  .onConflictOnColumn(_.username)
  .doUpdate(_.email) // .doNothing is also an option
  .run

// cache
val stm = sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .onConflictOnColumn(_.username)
  .doUpdate(_.email)
  .cache

stm.run(("bob", "bob@hotmail.com"))</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">INSERT INTO "user_profile"
("username", "email")
VALUES ('bob', 'bob@mail.com')
ON CONFLICT ("username")
DO UPDATE SET "email" = 'bob@mail.com'</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-6-6">
					<h2 class="section-heading">Insert where not exists</h2>
					<p>If you need to avoid duplication on a column that does not have a unique constraint you can use <code>whereNotExists</code>. Also, if you are makeing multible insert statements concurrently, from a stream for example, you will run into problems using <code>onConflictDoNothing</code>.<p>
					<div class="docs-code-block">
						<pre class="rounded">
							<code class="language-scala hljs">sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .values(("bob", "bob@mail.com"))
  .whereNotExists(_.username)
  .run

// cache
val stm = sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .whereNotExists(_.username)
  .cache

stm.run(("bob", "bob@mail.com"))</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">INSERT INTO "user_profile"
("username", "email")
SELECT 'bob', 'bob@mail.com'
WHERE NOT EXISTS (
  SELECT 1
  FROM "user_profile"
  WHERE "username" = 'bob'
)</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-6-7">
					<h2 class="section-heading">Insert from select</h2>
					<div class="docs-code-block">
						<pre class="rounded">
							<code class="language-scala hljs">sql
  .insert(newsletter)
  .cols1(_.email)
  .fromSelect(
    sql
      .select(user)
      .cols1(_.email)
      .where(_.isActive === true)
  )
  .run

// cache
val stm = sql
  .insert(newsletter)
  .cols1(_.email)
  .pickSelect(
    sql
      .select(user)
      .cols1(_.email)
      .pickWhere1(_.isActive.use === Arg)
  )
  .cache

stm.run(true)</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">INSERT INTO "newsletter" ("email")
SELECT "email"
FROM "user_profile"
WHERE "is_active" = true</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-6-8">
          <h2 class="section-heading">Insert many</h2>
          <div class="docs-code-block">
            <pre class="rounded">
              <code class="language-scala hljs">val stm = sql
  .insert(user)
  .cols2(t => (
    t.username,
    t.email
  ))
  .cache

stm.runList(Seq(
  ("bob", "bob@mail.com"),
  ("jane", "jane@mail.com"),
  ("jack", "jack@mail.com")
))</code>
              </pre>
            </div>
          </section>
        </article>

        <!-- Update -->

        <article class="docs-article" id="section-7">
				  <header class="docs-header">
				    <h1 class="docs-heading">Update</h1>
					</header>
					
					<section class="docs-section" id="item-7-1">
						<h2 class="section-heading">Update statement</h2>
						<p>See <a href="#item-17-3">Update operators</a></p>
						<p></p>
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">sql
  .update(user)
  .set(_.country ==> "JP")
  .where(_.id === 103)
  .run

// cache
val stm = sql
  .update(user)
  .pickSet1(_.country.use ==> Arg)
  .pickWhere1(_.id.use === Arg)
  .cache

stm.run("JP", 103)</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">UPDATE "user" SET "country" = 'JP' WHERE id = 103</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-7-2">
						<h2 class="section-heading">Update returning</h2>
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">sql
  .update(user)
  .set(t => Seq(
    t.country ==> "IS",
    t.city ==> "Reykjavik"
  ))
  .where(_.id === 31)
  .returning3(t => (
    t.id,
    t.country,
    t.city
  ))
  .runHeadOpt

// cache
val stm = sql
  .update(user)
  .pickSet2(t => (
    t.country.use ==> Arg,
    t.city.use ==> Arg
  ))
  .pickWhere1(_.id.use === Arg)
  .returning3(t => (
    t.id,
    t.country,
    t.city
  ))
  .cache

stm.runHeadOpt(("IS", "Reykjavik"), 31)</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">UPDATE "user_profile"
SET country = 'IS',
       city = 'Reykjavik'
WHERE "id" = 31
RETURNING
  "id",
  "country",
  "city"</code>
            	</pre>
            </div>
          </section>
        </article>

        <!-- Delete -->

        <article class="docs-article" id="section-8">
				  <header class="docs-header">
				    <h1 class="docs-heading">Delete</h1>
					</header>
					
					<section class="docs-section" id="item-8-1">
						<h2 class="section-heading">Delete statement</h2>
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">sql
  .delete(user)
  .where(_.id === 103)
  .run

// cache
val stm = sql
  .delete(user)
  .pickWhere1(_.id.use === Arg)
  .cache

stm.run(103)</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">DELETE FROM "user_profile" WHERE "id" = 103</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-8-2">
						<h2 class="section-heading">Delete returning</h2>
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">val stm = sql
  .delete(user)
  .where(_.id === 103)
  .returning1(_.email)
  .runHeadOpt

// cache
val stm = sql
  .delete(user)
  .pickWhere1(_.id.use === Arg)
  .returning1(_.email)

stm.runHeadOpt(103)</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">DELETE FROM "user_profile"
WHERE "id" = 103
RETURNING "email"</code>
            	</pre>
            </div>
          </section>
        </article>

        <!-- null values -->

        <article class="docs-article" id="section-9">
          <header class="docs-header">
            <h1 class="docs-heading">Null values</h1>
          </header>

          <section class="docs-section" id="item-9-1">
            <h2 class="section-heading">Null values in results</h2>
            <div class="docs-code-block">
              <p>Convert the column in the query from <code>T</code> to <code>Option[T]</code></p>
              <pre class="rounded">
                <code class="language-scala hljs">cols1(_.city.asOpt)</code>
              </pre>
              <p>Use Posgres's coalesce function to return a default value in case of null</p>
              <pre class="rounded">
                <code class="language-scala hljs">cols1(t => t.city.default("No city"))</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-9-2">
            <h2 class="section-heading">Insert and update null values</h2>
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">sql
  .insert(client)
  .cols2(t => (t.username, t.age.asOpt))
  .values(("Joe", None))
  .run
    
sql
  .update(client)
  .set(_.age.asOpt ==> None)
  .where(_.id === 4)
  .run</code>
              </pre>
            </div>
          </section>

        </article>

        <!-- Aggregation -->

        <article class="docs-article" id="section-10">
				  <header class="docs-header">
				    <h1 class="docs-heading">Aggregation</h1>
					</header>
					
					<section class="docs-section" id="item-10-1">
						<h2 class="section-heading">Count</h2>
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">sql
  .count(user)
  .where(_.country === "IT")
  .runHead</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">SELECT count(*) FROM "user_profile" WHERE "country" = 'IT'</code>
            	</pre>
            </div>
          </section>

          <section class="docs-section" id="item-10-2">
						<h2 class="section-heading">Avg Max Min</h2>
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">import kuzminki.api._
import kuzminki.fn._

sql
  .select(user)
  .cols3(t => (
    Agg.avg(t.age),
    Agg.max(t.age),
    Agg.min(t.age)
  ))
  .where(_.country === "US")
  .runHead</code>
            	</pre>
							<pre class="rounded">
								<code class="language-pgsql hljs">SELECT
  avg("age"),
  max("age"),
  min("age")
FROM "user_profile"
WHERE "country" = 'US'</code>
            	</pre>
            </div>
          </section>
        </article>

        <!-- Streaming -->

        <article class="docs-article" id="section-11">
          <header class="docs-header">
            <h1 class="docs-heading">Streaming</h1>
          </header>
          
          <section class="docs-section" id="item-11-1">
            <h2 class="section-heading">Stream from the database</h2>
            <p>Streaming is done in batches. By default a batch of 100. For a larger batch use .stream(1000)</p>
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">sql
  .select(client)
  .cols3(_.all)
  .all
  .orderBy(_.id.asc)
  .stream // .streamBatch(1000)
  .map(makeLine)
  .run(fileSink(Paths.get("clints.txt")))</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-11-2">
            <h2 class="section-heading">Stream into the database</h2>
            <p>The same logic can be used for UPDATE and DELETE.</p>
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">val insertStm = sql
  .insert(client)
  .cols2(t => (t.username, t.age))
  .cache

// insert one at a time.
readFileIntoStream("clints.txt")
  .map(makeTupleFromLine)
  .run(insertStm.asSink)

// insert in chunks of 100 using transaction.
readFileIntoStream("clints.txt")
  .map(makeTupleFromLine)
  .transduce(insertStm.collect(100))
  .run(insertStm.asChunkSink)</code>
              </pre>
            </div>
          </section>
        </article>

        <!-- Transaction -->

        <article class="docs-article" id="section-12">
          <header class="docs-header">
            <h1 class="docs-heading">Transaction</h1>
          </header>

          <section class="docs-section" id="item-12-1">
            <h2 class="section-heading">Execute multiple operations</h2>
            <p>Do INSERT, UPDATE and DELETE in one transaction.</p>
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">sql.transaction(
  sql.insert(user).cols2(t => (t.username, t.age)).values(("Joe", 25)),
  sql.update(user).set(_.age ==> 31).where(_.id === 45),
  sql.delete(user).where(_.id === 83)
).run</code>
              </pre>
            </div>

            <p>Execute a list of cached statements</p>

            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">val stm = sql
  .delete(user)
  .pickWhere1(_.id)
  .cache

val statements = (1 to 10).map(id => stm.render(id))

sql.transactionList(Seq(statements)).run</code>
              </pre>
            </div>
          </section>
        </article>

        <!-- Debug -->

        <article class="docs-article" id="section-13">
          <header class="docs-header">
            <h1 class="docs-heading">Debug</h1>
          </header>

          <section class="docs-section" id="item-13-1">
            <h2 class="section-heading">Print the query</h2>
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">sql
  .select(client)
  .cols3(_.all)
  .where(_.age > 25)
  .limit(5)
  .printSqlWithArgs
  .run
// SELECT "id", "username", "age" FROM "client" WHERE "age" > 25 LIMIT 5

sql
  .update(client)
  .set(_.age ==> 24)
  .where(_.id === 4)
  .printSql
  .run
// UPDATE "client" SET "age" = ? WHERE id = ?</code>
              </pre>
            </div>
          </section>
        </article>

        <!-- Fields -->

        <article class="docs-article" id="section-14">
          <header class="docs-header">
            <h1 class="docs-heading">Fields</h1>
          </header>

          <section class="docs-section" id="item-14-1">
            <h2 class="section-heading">Jsonb field</h2>
            <p><a href="https://www.postgresql.org/docs/11/functions-json.html">https://www.postgresql.org/docs/11/functions-json.html</a></p>
            
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-json hljs">{
  "name": "Angela Barton",
  "is_active": true,
  "company": "Magnafone",
  "address": "178 Howard Place, Gulf, Washington, 702",
  "latitude": 19.793713,
  "longitude": 86.513373,
  "tags": ["enim", "aliquip", "qui"],
  "residents": {
    "name": "Rick",
    "age": 31
  }
}</code>
              </pre>
            </div>

            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">class Customer extends Model("customer") {
  val data = column[Jsonb]("data")
}

sql
  .insert(customer)
  .cols1(_.data)
  .values(Jsonb(jsonString))
  .run

// select

sql
  .select(customer)
  .cols1(_.data ->> "company")
  .where(_.id === 3)
  .runHead // "Magnafone"


sql
  .select(customer)
  .cols1(_.data #>> Seq("residents", "name"))
  .where(_.id === 3)
  .runHead // "Rick"


sql
  .select(customer)
  .cols1(_.data -> "tags" ->> 1)
  .where(_.id === 3)
  .runHead // "aliquip"


sql
  .select(customer)
  .cols1(_.data -> "residents")
  .where(_.id === 3)
  .runHead // Jsonb({"name" : "Rick", "age" : 31})

sql
  .select(customer)
  .cols1(_.data - "residents")
  .where(_.id === 3)
  .runHead

sql
  .select(customer)
  .cols1(t => t.data || t.other)
  .where(_.id === 3)
  .runHead

// update

sql
  .update(customer)
  .set(_.data += Json.obj("address" -> "Somewhere 12"))
  .where(_.id === 3)
  .run

  
sql
  .update(customer)
  .set(_.data -= "address")
  .where(_.id === 3)
  .run


sql
  .update(customer)
  .set(_.data #-= Seq("residents", "age"))
  .where(_.id === 3)
  .run</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-14-2">
            <h2 class="section-heading">Array field</h2>
            <p>Array fields can be created for all the available types.</p>
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">class Nums extends Model("demo") {
  val id = column[Int]("id")
  val numbers = column[Seq[Int]]("numbers")
}

val nums = Model.get[Nums]

for {
  id <- sql
    .insert(nums)
    .cols1(_.numbers)
    .values(List(1, 2, 3))
    .returning1(_.id)
    .run

  _ <- sql
    .update(nums)
    .set(_.numbers += 4)
    .where(_.id === id)
    .run

  numbers <- sql
    .select(nums)
    .cols1(_.numbers)
    .where(_.numbers ? 2)
    .run
} yield numbers // List[Vector[Int]]</code>
              </pre>
            </div>
            <p>Unique and sorted
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">// add element and and make sure it is unique
.set(_.numbers.add(4))

// add list of element and and make sure they are unique
.set(_.numbers.add(List(8, 7, 7, 2)))

// same as add but sorted
.set(_.numbers.addAsc(4))
.set(_.numbers.addDesc(4))

// for jsonb array, a key has to be provided that should be unique and used for sorting
.set(_.numbers.addDesc(jsonObj, "index"))

// cache
.pickSet1(_.numbers.addAsc(Arg))
// to use a list as argument
.pickSet1(_.numbers.addAsc(ArgSeq))</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-14-3">
            <h2 class="section-heading">Timestamp, Date, Time</h2>
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">class Demo extends Model("demo") {
  val id = column[Int]("id")
  val eventTime = column[Time]("event_time")
  val eventDate = column[Date]("event_date")
  val updatedAt = column[Timestamp]("updated_at")
}

val demo = Model.get[Demo]

sql
  .update(demo)
  .set(t => Seq(
    t.eventTime += Fn.interval(hours = 3, minutes = 10),
    t.eventDate += Fn.interval(years = 1, days = 2),
    t.updatedAt += Fn.interval(months = 4, hours = 5)
  ))
  .where(_.id === 25)
  .run

sql
  .select(demo)
  .cols3(t => (
    t.eventTime.format("MM:HH"),
    t.eventDate.format("DD Mon YYYY"),
    t.updatedAt.format("DD Mon YYYY MM:HH")
  ))
  .where(_.id === 25)
  .runHead

sql
  .select(demo)
  .cols4(t => (
    t.id,
    t.eventDate.month,
    t.updatedAt.week
    t.updatedAt + Fn.interval(days = 10)
  ))
  .where(t => Seq(
    t.eventDate.year === 2022,
    t.eventDate.quarter === 2
  ))
  .run</code>
              </pre>
            </div>
          </section>
        </article>

        <!-- Functions -->

        <article class="docs-article" id="section-15">
          <header class="docs-header">
            <h1 class="docs-heading">Functions</h1>
          </header>
          
          <section class="docs-section" id="item-15-1">
            <h2 class="section-heading">Postgres functions</h2>
            <p>Use postgres functions to modify results.</p>
            
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">import kuzminki.api._
import kuzminki.fn._

class Profile extends Model("profile") {
  val firstName = column[String]("first_name")
  val lastName = column[String]("last_name")
  val bigNum = column[BigDecimal]("big_num")
}

val profile = Model.get[Profile]

sql
  .select(profile)
  .cols3(t => (
    Fn.concatWs(" ", t.firstName, t.lastName),
    Fn.initcap(t.lastName),
    Cast.asString(t.bigNum)
  ))
  .all
  .run</code>
              </pre>
            </div>
          </section>

          <section class="docs-section" id="item-15-3">
            <h2 class="section-heading">Create functions</h2>
            <p>Create your own function classes.</p>
            <div class="docs-code-block">
              <pre class="rounded">
                <code class="language-scala hljs">import kuzminki.fn.StringFn

case class FullName(
  title: String,
  first: TypeCol[String],
  second: TypeCol[String]
) extends StringFn {
  val name = "full_name"
  val template = s"concat_ws(' ', '$title', %s, %s)"
  val cols = Vector(first, second)
}

sql
  .select(user)
  .cols2(t => (
    t.id,
    FullName("Mr", t.firstName, t.lastName)
  ))
  .where(_.id === 10)
  .runHead

// If you need to have the driver fill in arguments:

case class FullNameParam(
  title: String,
  first: TypeCol[String],
  second: TypeCol[String]
) extends StringParamsFn {
  val name = "full_name"
  val template = s"concat_ws(' ', ?, %s, %s)"
  val cols = Vector(first, second)
  val params = Vector(title)
}</code>
              </pre>
            </div>

          </section>

          <section class="docs-section" id="item-15-4">
            <h2 class="section-heading">Available functions</h2>
            <p><a href="https://www.postgresql.org/docs/current/functions-string.html">https://www.postgresql.org/docs/current/functions-string.html</a>
            <div class="table-responsive my-4">
              <table class="table table-bordered">
                <tbody>
                  <tr>
                      <th>Function</th>
                      <th>Column type</th>
                  </tr>
                  <tr>
                      <td>Fn.coalesce(col, default)</td>
                      <td>String</td>
                  </tr>
                   <tr>
                      <td>Fn.concat(col, ...)</td>
                      <td>String</td>
                  </tr>
                   <tr>
                      <td>Fn.concatWs(glue, col, ...)</td>
                      <td>String</td>
                  </tr>
                   <tr>
                      <td>Fn.substr(col, start)</td>
                      <td>String</td>
                  </tr>
                   <tr>
                      <td>Fn.substr(col, start, len)</td>
                      <td>String</td>
                  </tr>
                   <tr>
                      <td>Fn.trim(col)</td>
                      <td>String</td>
                  </tr>
                  <tr>
                      <td>Fn.upper(col)</td>
                      <td>String</td>
                  </tr>
                  <tr>
                      <td>Fn.lower(col)</td>
                      <td>String</td>
                  </tr>
                  <tr>
                      <td>Fn.initcap(col)</td>
                      <td>String</td>
                  </tr>
                  <tr>
                      <td>Fn.round(col)</td>
                      <td>BigDecimal</td>
                  </tr>
                  <tr>
                      <td>Fn.roundStr(col)</td>
                      <td>BigDecimal</td>
                  </tr>
                  <tr>
                      <td>Cast.asString(col)</td>
                      <td>Any</td>
                  </tr>
                  <tr>
                      <td>Cast.asShort(col)</td>
                      <td>Any</td>
                  </tr>
                  <tr>
                      <td>Cast.asInt(col)</td>
                      <td>Any</td>
                  </tr>
                  <tr>
                      <td>Cast.asLong(col)</td>
                      <td>Any</td>
                  </tr>
                  <tr>
                      <td>Cast.asFloat(col)</td>
                      <td>Any</td>
                  </tr>
                  <tr>
                      <td>Cast.asDouble(col)</td>
                      <td>Any</td>
                  </tr>
                  <tr>
                      <td>Cast.asBigDecimal(col)</td>
                      <td>Any</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
        </article>

        <!-- Raw SQL -->

        <article class="docs-article" id="section-16">
				  <header class="docs-header">
				    <h1 class="docs-heading">Raw SQL</h1>
					</header>
					
					<section class="docs-section" id="item-16-1">
						<h2 class="section-heading">Select</h2>
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">def rawStm(country: String, minAge: Int) =
  rsql"""SELECT * FROM "user_profile" WHERE country = $country AND age > $minAge"""

val job = for {
  users <- db.query(rawStm("TR", 25))
} yield users</code>
							</pre>
            </div>
          </section>

          <section class="docs-section" id="item-16-2">
						<h2 class="section-heading">Operations</h2>
						<div class="docs-code-block">
							<pre class="rounded">
								<code class="language-scala hljs">val username = "bob"
val email = "bob@mail.com"

db.exec(rsql"""INSERT INTO "user_profile" ("username", "email") VALUES ($username, $email)""")</code>
            	</pre>
            </div>
          </section>
        </article>

        <!-- Data types and operators -->

        <article class="docs-article" id="section-17">
				  <header class="docs-header">
				    <h1 class="docs-heading">Data types and operators</h1>
					</header>
					
					<section class="docs-section" id="item-17-1">
						<h2 class="section-heading">Data types</h2>
						<div class="table-responsive my-4">
							<table class="table table-bordered">
								<tbody>
								  <tr>
									    <th class="theme-bg-light">Postgres</th>
									    <th>Scala</th>
									</tr>
									<tr>
									      <td class="theme-bg-light">varchar / text</td>
									      <td>String</td>
									</tr>
									<tr>
									    <td class="theme-bg-light">bool</td>
									    <td>Boolean</td>
									</tr>
									<tr>
									    <td class="theme-bg-light">int2</td>
									    <td>Short</td>
									</tr>
									<tr>
									    <td class="theme-bg-light">int4</td>
									    <td>Int</td>
									</tr>
									<tr>
									    <td class="theme-bg-light">int8</td>
									    <td>Long</td>
									</tr>
									<tr>
									    <td class="theme-bg-light">float4</td>
									    <td>Float</td>
									</tr>
									<tr>
									    <td class="theme-bg-light">float8</td>
									    <td>Double</td>
									</tr>
									<tr>
									    <td class="theme-bg-light">numeric</td>
									    <td>BigDecimal</td>
									</tr>
                  <tr>
                      <td class="theme-bg-light">time</td>
                      <td>java.sql.Time</td>
                  </tr>
									<tr>
									    <td class="theme-bg-light">date</td>
									    <td>java.sql.Date</td>
									</tr>
									<tr>
									    <td class="theme-bg-light">timestamp</td>
									    <td>java.sql.Timestamp</td>
									</tr>
                  <tr>
                      <td class="theme-bg-light">uuid</td>
                      <td>java.util.UUID</td>
                  </tr>
                  <tr>
                      <td class="theme-bg-light">jsonb</td>
                      <td>kuzminki.api.Jsonb(value: String)</td>
                  </tr>
								</tbody>
							</table>
						</div>
          </section>

          <section class="docs-section" id="item-17-2">
						<h2 class="section-heading">Operators</h2>
						<div class="table-responsive my-4">
							<table class="table table-bordered">
								<tbody>
								    <tr>
									    <th>Operator</th>
									    <th>Column type</th>
                      <th>Argumeent</th>
                      <th>Explainattion</th>
									</tr>
									<tr>
									    <td>===</td>
									    <td>Any</td>
                      <td>T</td>
                      <td></td>
									</tr>
									<tr>
									    <td>!==</td>
									    <td>Any</td>
                      <td>T</td>
                      <td></td>
									</tr>
                  <tr>
                      <td>in</td>
                      <td>Any</td>
                      <td>T</td>
                      <td>Seq[T], Subquery[T]</td>
                  </tr>
                  <tr>
                      <td>notIn</td>
                      <td>Any</td>
                      <td>T</td>
                      <td>Seq[T], Subquery[T]</td>
                  </tr>
                  <!-- comperative -->
									<tr>
									    <td>></td>
									    <td>Numbers and time</td>
                      <td>T</td>
                      <td></td>
									</tr>
									<tr>
									    <td><</td>
									    <td>Numbers and time</td>
                      <td>T</td>
                      <td></td>
									</tr>
									<tr>
									    <td>>=</td>
									    <td>Numbers and time</td>
                      <td>T</td>
                      <td></td>
									</tr>
									<tr>
									    <td><=</td>
									    <td>Numbers and time</td>
                      <td>T</td>
                      <td></td>
									</tr>
                  <!-- string -->
									<tr>
									    <td>~</td>
									    <td>String</td>
                      <td>String</td>
                      <td>Match</td>
									</tr>
									<tr>
									    <td>~*</td>
									    <td>String</td>
                      <td>String</td>
                      <td>Match case insensitive</td>
									</tr>
									<tr>
									    <td>!~</td>
									    <td>String</td>
                      <td>String</td>
                      <td>Not match</td>
									</tr>
									<tr>
									    <td>!~*</td>
									    <td>String</td>
                      <td>String</td>
                      <td>Not match case insensitive</td>
									</tr>
									<tr>
									    <td>like</td>
									    <td>String</td>
                      <td>String</td>
                      <td></td>
									</tr>
									<tr>
									    <td>starts</td>
									    <td>String</td>
                      <td>String</td>
                      <td></td>
									</tr>
									<tr>
									    <td>ends</td>
									    <td>String</td>
                      <td>String</td>
                      <td></td>
									</tr>
									<tr>
									    <td>similarTo</td>
									    <td>String</td>
                      <td>String</td>
                      <td></td>
									</tr>
                  <!-- array -->
                  <tr>
                      <td>?</td>
                      <td>Array</td>
                      <td>T</td>
                      <td>Exists</td>
                  </tr>
                  <tr>
                      <td>!?</td>
                      <td>Array</td>
                      <td>T</td>
                      <td>Not exists</td>
                  </tr>
                  <tr>
                      <td>@></td>
                      <td>Array</td>
                      <td>Seq[T]</td>
                      <td>Contains</td>
                  </tr>
                  <tr>
                      <td>!@></td>
                      <td>Array</td>
                      <td>Seq[T]</td>
                      <td>Not contains</td>
                  </tr>
                  <tr>
                      <td><@</td>
                      <td>Array</td>
                      <td>Seq[T]</td>
                      <td>Contained by</td>
                  </tr>
                  <tr>
                      <td>!<@</td>
                      <td>Array</td>
                      <td>Seq[T]</td>
                      <td>Not contained by</td>
                  </tr>
                  <tr>
                      <td>&&</td>
                      <td>Array</td>
                      <td>Seq[T]</td>
                      <td>Overlaps</td>
                  </tr>
                  <tr>
                      <td>!&&</td>
                      <td>Array</td>
                      <td>Seq[T]</td>
                      <td>Not overlaps</td>
                  </tr>
                  <!-- jsonb -->
                  <tr>
                      <td>?</td>
                      <td>Jsonb</td>
                      <td>String</td>
                      <td>Exists</td>
                  </tr>
                  <tr>
                      <td>!?</td>
                      <td>Jsonb</td>
                      <td>String</td>
                      <td>Not exists</td>
                  </tr>
                  <tr>
                      <td>?|</td>
                      <td>Jsonb</td>
                      <td>Seq[String]</td>
                      <td>Exists any</td>
                  </tr>
                  <tr>
                      <td>?&</td>
                      <td>Jsonb</td>
                      <td>Seq[String]</td>
                      <td>Exists all</td>
                  </tr>
                  <tr>
                      <td>@></td>
                      <td>Jsonb</td>
                      <td>Jsonb</td>
                      <td>Contains</td>
                  </tr>
                  <tr>
                      <td>!@></td>
                      <td>Jsonb</td>
                      <td>Jsonb</td>
                      <td>Not contains</td>
                  </tr>
                  <tr>
                      <td><@</td>
                      <td>Jsonb</td>
                      <td>Jsonb</td>
                      <td>Contained by</td>
                  </tr>
                  <tr>
                      <td>!<@</td>
                      <td>Jsonb</td>
                      <td>Jsonb</td>
                      <td>Not contained by</td>
                  </tr>
								</tbody>
							</table>
						</div>
          </section>

          <section class="docs-section" id="item-17-3">
						<h2 class="section-heading">Update operators</h2>
						<div class="table-responsive my-4">
							<table class="table table-bordered">
								<tbody>
								  <tr>
									    <th>Operator</th>
                      <th>Column type</th>
                      <th>Argumeent</th>
                      <th>Explainattion</th>
									</tr>
									<tr>
									    <td>==></td>
                      <td>Any</td>
                      <td>T</td>
                      <td></td>
									</tr>
									<tr>
									    <td>+=</td>
                      <td>Numbers</td>
                      <td>T</td>
                      <td>Increase</td>
									</tr>
									<tr>
									    <td>-=</td>
                      <td>Numbers</td>
                      <td>T</td>
                      <td>Decrease</td>
									</tr>
                  <tr>
                      <td>setNow</td>
                      <td>Timestamp, Date, Tiime</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>+=</td>
                      <td>Timestamp, Date, Tiime</td>
                      <td>PGInterval</td>
                      <td>Increase</td>
                  </tr>
                  <tr>
                      <td>-=</td>
                      <td>Timestamp, Date, Tiime</td>
                      <td>PGInterval</td>
                      <td>Decrease</td>
                  </tr>
                  <tr>
                      <td>+=</td>
                      <td>Array</td>
                      <td>T, Seq[T]</td>
                      <td>Append</td>
                  </tr>
                  <tr>
                      <td>:=</td>
                      <td>Array</td>
                      <td>T, Seq[T]</td>
                      <td>Prepend</td>
                  </tr>
                  <tr>
                      <td>-=</td>
                      <td>Array</td>
                      <td>T</td>
                      <td>Remove</td>
                  </tr>
                  <tr>
                      <td>add</td>
                      <td>Array</td>
                      <td>T, Seq[T]</td>
                      <td>Add unique</td>
                  </tr>
                  <tr>
                      <td>addAsc</td>
                      <td>Array</td>
                      <td>T, Seq[T]</td>
                      <td>Add unique and sort asc</td>
                  </tr>
                  <tr>
                      <td>addDesc</td>
                      <td>Array</td>
                      <td>T, Seq[T]</td>
                      <td>Add unique and sort desc</td>
                  </tr>
                  <tr>
                      <td>+=</td>
                      <td>Jsonb</td>
                      <td>Jsonb</td>
                      <td>Extend</td>
                  </tr>
                  <tr>
                      <td>-=</td>
                      <td>Jsonb</td>
                      <td>String, Int</td>
                      <td>Remove</td>
                  </tr>
                  <tr>
                      <td>#-=</td>
                      <td>Jsonb</td>
                      <td>Seq[String]</td>
                      <td>Remove path</td>
                  </tr>
								</tbody>
							</table>
						</div>
          </section>

          <section class="docs-section" id="item-17-4">
            <h2 class="section-heading">Modifiers</h2>
            <div class="table-responsive my-4">
              <table class="table table-bordered">
                <tbody>
                  <tr>
                      <th>Operator</th>
                      <th>Column type</th>
                      <th>Argumeent</th>
                      <th>Explainattion</th>
                  </tr>
                  <tr>
                      <td>default</td>
                      <td>Any</td>
                      <td>T</td>
                      <td>If null, return default</td>
                  </tr>
                  <tr>
                      <td>concat</td>
                      <td>String</td>
                      <td>String, ...</td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>concatWs</td>
                      <td>String</td>
                      <td>(String, Any, ...)</td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>substr</td>
                      <td>String</td>
                      <td>Int, (Int, Int)</td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>replace</td>
                      <td>String</td>
                      <td>(String, String)</td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>trim</td>
                      <td>String</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>upper</td>
                      <td>String</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>lower</td>
                      <td>String</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>initcap</td>
                      <td>String</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>asShort</td>
                      <td>String</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>asInt</td>
                      <td>String</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>asLong</td>
                      <td>String</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>asFloat</td>
                      <td>String</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>asDouble</td>
                      <td>String</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>asBigDecimal</td>
                      <td>String</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>round</td>
                      <td>Numbers</td>
                      <td>Int</td>
                      <td>Returns BigDecimal</td>
                  </tr>
                  <tr>
                      <td>roundStr</td>
                      <td>Numbers</td>
                      <td>Int</td>
                      <td>Returns String</td>
                  </tr>
                  <tr>
                      <td>age</td>
                      <td>Timestamp</td>
                      <td></td>
                      <td>Returns PgInterval</td>
                  </tr>
                  <tr>
                      <td>epochSecs</td>
                      <td>Timestamp</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>epochMillis</td>
                      <td>Timestamp</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>century</td>
                      <td>Timestamp, Date</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>decade</td>
                      <td>Timestamp, Date</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>year</td>
                      <td>Timestamp, Date</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>quarter</td>
                      <td>Timestamp, Date</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>month</td>
                      <td>Timestamp, Date</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>week</td>
                      <td>Timestamp, Date</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>day</td>
                      <td>Timestamp, Date</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>dow</td>
                      <td>Timestamp, Date</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>doy</td>
                      <td>Timestamp, Date</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>isoDow</td>
                      <td>Timestamp, Date</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>isoYear</td>
                      <td>Timestamp, Date</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>hour</td>
                      <td>Timestamp, Time</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>minute</td>
                      <td>Timestamp, Time</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>second</td>
                      <td>Timestamp, Time</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>microseconds</td>
                      <td>Timestamp, Time</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>milliseconds</td>
                      <td>Timestamp, Time</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>asDate</td>
                      <td>Timestamp</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>asTime</td>
                      <td>Timestamp</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>asTimestamp</td>
                      <td>Timestamp</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>asString</td>
                      <td>Timestamp, Date, Time</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>format</td>
                      <td>Timestamp, Date, Time</td>
                      <td>String</td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>unnest</td>
                      <td>Array</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>length</td>
                      <td>Array</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>trim</td>
                      <td>Array</td>
                      <td>Int</td>
                      <td>Get the first x elements</td>
                  </tr>
                  <tr>
                      <td>get</td>
                      <td>Array</td>
                      <td>Int</td>
                      <td>Get the element at a given 1 based index</td>
                  </tr>
                  <tr>
                      <td>pos</td>
                      <td>Array</td>
                      <td>T</td>
                      <td>Index of the given element</td>
                  </tr>
                  <tr>
                      <td>first</td>
                      <td>Array</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>last</td>
                      <td>Array</td>
                      <td></td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>join</td>
                      <td>Array</td>
                      <td>String</td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>||</td>
                      <td>Array</td>
                      <td>TypeCol[T]</td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>-></td>
                      <td>Jsonb</td>
                      <td>String, Int</td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>->></td>
                      <td>Jsonb</td>
                      <td>String, Int</td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>#></td>
                      <td>Jsonb</td>
                      <td>Seq[String]</td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>#>></td>
                      <td>Jsonb</td>
                      <td>Seq[String]</td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>||</td>
                      <td>Array</td>
                      <td>TypeCol[Jsonb]</td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>-</td>
                      <td>Jsonb</td>
                      <td>String, Int, Seq[String]</td>
                      <td></td>
                  </tr>
                  <tr>
                      <td>#-</td>
                      <td>Jsonb</td>
                      <td>Seq[String]</td>
                      <td></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
        </article>



		    <footer class="footer">
			    <div class="container text-center py-5">
		        <small class="copyright">Template Copyright &copy; <a href="https://themes.3rdwavemedia.com/" target="_blank">3rd Wave Media</a></small>
		        <ul class="social-list list-unstyled pt-4 mb-0">
				    	<li class="list-inline-item">
				    		<a href="https://github.com/karimagnusson/kuzminki-zio" target="_blank">
				    			<i class="fab fa-github fa-fw"></i>
				    		</a>
				    	</li> 
		        </ul>
			    </div>
		    </footer>
	    </div>
    </div>
  </div>
   
       
    <!-- Javascript -->          
    <script src="assets/plugins/popper.min.js"></script>
    <script src="assets/plugins/bootstrap/js/bootstrap.min.js"></script>  
    
    
    <!-- Page Specific JS -->
    <script src="assets/plugins/smoothscroll.min.js"></script>
    <script defer src="assets/js/pgsql.min.js"></script>
    <script defer src="assets/js/sql.min.js"></script>
   	<!--<script defer src="assets/js/highlight.min.js"></script>-->
   	<script defer src="assets/js/scala.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
    <script src="assets/js/highlight-custom.js"></script>
    <script src="assets/plugins/simplelightbox/simple-lightbox.min.js"></script>      
    <script src="assets/plugins/gumshoe/gumshoe.polyfills.min.js"></script> 
    <script src="assets/js/docs.js"></script> 

</body>
</html> 

